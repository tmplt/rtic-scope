#+SEQ_TODO: TODO STARTED | DONE CANCELLED

* Master's theses in Rust and embedded systems
Next meet planned for [2021-01-15 Fri] before the next semester begins.

** Proposed theses
1. Safe approximation of path WCET
   - Topcs: KLEE; symbolic execution/verification; optimization levels/layers.
   - Application of research related to scheduling.
   - Probable communication with London team.
   - Analysis of how KLEE/LLVM behaves.
2. LLVM-IR as as approx WCET
   - Map LLVM-IR instuctions to architecture instuction count and
     execution time.
   - Topics: how programs are written; algorithms; trade-off between
     correctness and work-load; compilation technology/theory.
3. Program analasys using formal methods
   - Path explosion and how to detect and analyse them.
   - Topics: Mathematics, formal proofs
4. Tooling: RTIC -> test gen -> automated measurements -> analysis ->
   presentation.
   - Probably popular commercially.
5. Better debug for optimized code
   - DWARF in ELF
   - Probe.rs and/or GDB.
6. Map out tasks that take resources and send/recv messages in
   real-time.
   - Allegedly a lot applications.
   - Catch events from a host-site application and present them.
   - Related to thesis 4?
7. RTIC + FPGA + VHDL + RISCV
   - Experiments with interrupt HW implementation.
   - Porting RTIC to another architecture.
   - NVIC implementation.
   - Symbolic implementation of implementations.

* Meeting at Grepit, [2021-01-13 Wed]; RTIC Scope
- ITM-, ETM-baserad tracing
- TPUI periph
  - intern buffer
  - snackar seriellt över en ~swo~-port


** DONE Peripherals of interest
   SCHEDULED: <2021-01-18 Mon>
# Most descriptions are from the ARM Cortex-M4 Technical Reference Manual
- ITM :: Instumentation Trace Macrocell: application-driven trace source
  that supports =printf=-style debugging to trace operating system and
  application events, and generates diagnostic system information. The
  ITM generates trace information as packets from software traces, time
  stamping and global timestamping sources. [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::682++0.00][ITM is a non-invasive form
  of debugging.]]
- ETM :: real-time trace module providing instuction and data tracing of
  a processor. An ETM is an integral part of an ARM RealView debug solution.
- DWT :: Data Watchpoint and Trace: contains four comparators that can
  be configured as hardware watchpoints, ETM triggers, PC sampler event
  trigger, or a data address sampler event trigger.
- TPIU :: Trace Port Interface Unit: acts as a bridge between the
  on-chip trace data from the Embedded Trace Macrocell (ETM) and the
  Instumentation Trace Macrocell (ITM), with seperate IDs, to a data
  stream. The TPIU encapsulates IDs where required, and the data stream
  is then captured by a Trace Port Analyzer (TPA).
- RTT :: Real-Time Transfer: J-Link/SEGGER-defined protocol for tracing
  via memory buffer. Supported by ~probe.rs~. Allegedly implemented
  using a simple ring buffer.
- Watch points :: Similar to breakpoints; but instead of ~PC~ match,
  debug state is entered when a memory address of interest (and/or a
  variable) is accessed. Can be set on any memory address in any type of
  memory.

*** [[pdf:~/sync/uni/exjobb/dm00119316-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf::823++0.00][Instumentation Trace Macrocell]] (ITM)
The ITM emits trace information as packets which can be generated as:
- Software trace :: Software can write directly to the ITM stimulus
  registers to emit packets.
- Hardware trace :: The Data Watchpoint Trigger (DWT) generates these
  packets, and the ITM emits them.
- Time stamping :: Timestampings are emitted relative to packets. The
  ITM contains a 21-bit counter to generate the timestamp. The Cortex-M4
  with FPU clock or the bit clock rate of the /Serial Wire Viewer/ (SWV)
  outputs clocks the counter.

The packets are emitted by the ITM are output to the TPIU. The formatter
of the TPIU adds some extra packets and then output the complete packet
sequence to the debugger host.

**** Stimulus ports
- Write all ones to the Trace Privilege Register and read-back; the
  number of ones tell us how many stimulus ports the device has. Always
  a multiple of 8.
- [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::709++0.00][*Writes to stimulus ports must be properly aligned.*]] Non-aligned
  access is /unpredictable/.
- Data written, ~(port ID, write size, data)~, is combined into a packet
  written to FIFO.
- If FIFO is full, *packet disgarded*, and Overflow packet generated.
- Reading stimulus port register of enabled stim. port indicates buffer
  status. *Watchpoint this register to keep an eye on buffer status over
  ITM*. A proposed impl. detail is to check buffer status before
  stimulating. /How does this help?/
- *DWT uses a different output buffer*.

**** Timestamps
[[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::710++0.00][Provide information on the timing of event generation with respect to
their visibility at a trace output port.]]

***** Local timestamps
      Delta timestamp values: each local timestamp indicates the elapsed
      time since generating the previous local timestamp. Generated from
      the timestamp clock in the ITM peritheral. Clock is reset on each
      generation.

      Implementation definitions:
      - timestamp counter size;
      - [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::710++2.71][whether sync or async clock can be used and/or diveded]];

      When a timestamp counter overflows, timer is reset and Overflow
      packet is generated. Subsequently, a local timestamp packet is
      sent. This packet can be preemped, but will always have the
      appropriate value. Local timestamps are maximum 28b. Leading
      zeroes are truncated.

***** Global timestamps
      Absolute timestamp values based on a system global timestamp
      clock. 48b /or/ 68b large. Global timestamps are send in two
      packets.

**** Synchonization support
     Syncronization packets are regularly generated. These can be used
     as a system heartbeat, if enabled. Used to recover bit-to-byte
     aligngment information in a data stream.

*** [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::719++0.00][Data Watchpoint and Trace unit]] (DWT)
    Provides (implementation defined; *can be determined*):
    - Comparators, that support:
      - watchpoints (on memory address), causes the processor to enter Debug state of take a
        DebugMonitor exception;
      - data tracing;
      - signaling for use with an external resource, e.g. ETM;
      - PC value tracking;
      - Cycle count matching;
    - Additional PC sampling:
      - PC sample trace output as a result of a cycle count event;
      - external PC sampling using a PC sample register;
    - exception trace; and
    - performance profiling counters.


**** DWT comparators
     Includes up to 15 comparators that compares:
     - a data address;
     - an instuction address/mask (a range of addresses can be compared against);
     - a data value; and
     - the cycle count counter (comparator 0 only).

     A DWT Data trace packet contains:
     - address of the instuction that caused data access;
     - Bits[15:0] of data access address; and
     - matched data value.

     Exception trace packets can be generated when an exception handler
     is entered. Can also be generated when excpetion handler is
     returned from.

*** [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::749++0.00][Embedded Trace Macrocell]] (ETM)
    Specified in some other document, according to some ETM architecture
    v3.4.

*** [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::750++0.00][Trace Port Interface Unit]] (TPIU)
    A simple bridge between internal debug peripherals (DWT, ITM) the
    outside world. An ARMv7-M compliant TPIU may provide an asynchronous
    /Serial Wire Output/ (SWO). SWO can be used to sidestep the STLink,
    and remove complexity from the export chain.

** DONE Read up on [[https://github.com/japaric/itm-tools][itm-tools]]
   CLOSED: [2021-01-19 Tue 22:14] SCHEDULED: <2021-01-18 Mon>

# Also read: RM368 for the stm32f401/f411, DDI0403E for the theory
# behind tracing and debugging, DDI0439B on some M4 definitions, RM0090
# (reference manual).

** Useful links
- [probe.rs]; we want to extend this and see how it works.
- [Druid] for GUI programming

** Notes
- modify the dispather to call ITM on dispatch, use ~probe.rs~ to catch
  ITM package, forward to host.
- how do we synchronize target and host? What needs to be synchronized?
  (Host and target are running in parallel here)
- intercept SWO line with dedicated hardware.
- HS probe :: open source programmer built from the ground up with the
  Rust in mind. Replicated by Grepit
- Serial TX on the Nucleo to bypass the ST-Link (which forces us to use
  openocd, which we do not want to use)
- Snacka med Johan gällande rymdapplikationer nu under 2021.
  - Specifikt med rymdföretag etablerade i Kiruna

* Meeting at Grepit, [2021-01-21 Thu];
** Notes
- "Knurling Defmt" for real-time tracing.
- =wfi= causes problems with ITM, RTT.
- Remove openocd from the chain as a start: TPIU must be configured just
  as in openocd. Lackluster API in probe.rs; fork it and experiment with
  values, etc.

** DONE fill in thesis template and submit
   CLOSED: [2021-01-25 Mon 15:34] SCHEDULED: <2021-01-25 Mon>

** TODO Merge Gabriel's notes below into this document
   Gabriel will work on some other stuff from now on.

*** Notes regarding ITM investigation/research
- Default clocks:
  - SAME5x: 48Mhz
  - F407: 16Mhz
  - F103: 8Mhz
- On SAME5x boards neither TPIU/ITM openocd commands nor probe-rs API is
  sufficient to enable ITM. *Additional steps*:
  - Enable ~GCLK_CM4_TRACE~ clock
  - Set PC27 into function M (~GCLK -> CORTEX_M/SWO~)
    - Question: Is it possible to setup SWO on PB30 pin and if so - how?
      (~SAM_D5xE5x_Family_Data_Sheet_DS60001507F.pdf~; p. 37)
- All platforms
  - Local timestamping (LTS; ~ITM.TCR.TSENA~ enabled) without asynchronous
    clock from TPIU (~ITM.TCR.SWOENA~ disabled) seems to work fine
    although there're also LTS packets without any event associated with
    it popping up regularly on SWO. These are supposedly overflow
    packets because the counter value they carry is suspiciously similar
    to MAX(21-bit unsigned) and LTS counter is 21 bit. This goes however
    against the specification that says that there should be Overflow
    packet + LTS packet, not just LTS packet (ARMv7-M arch ref
    manual; p. 711)
  - Local timestamping (LTS; ITM.TCR.TSENA enabled) with asynchronous
    clock from TPIU (ITM.TCR.SWOENA enabled) counts very slow and as
    such is pretty useless. I don't understand asynchronous clocking of
    ITM and what is it for so I didn't dig further
  - Global timestamping (GTS; ITM.TCR.GTSFREQ != 0x0) seems to be not
    clocked at all regardless of configuration (0x1,0x2,0x3). I couldn't
    find any additional information on the topic; maybe there's
    additional clock that needs to be setup on a per MCU basis?
  - PC sampling (DWT.CTRL.PCSAMPLENA enabled) does not work on F103;
    seems to work fine on F407. I didn't dig much further because I run
    out of time; sampling rate is configurable through other registers.
    If it's higher than ITM throughput - overflow guaranteed. I was able
    to use `pcsampl` tool to profile an application. Pretty nice.
  - Exception tracing (DWT.CTRL.EXCTRCENA enabled) does not work on
    F103; seems to work fine on F407. I was not able to parse SWO data
    with `excevt` because few malformed packets in datastream cause
    parser failure.
  - WFI does not seem to affect the behaviour of tracing module on F407
- Tools & URLs & Docs & Etc
  - @bcantrill from probe-rs Matrix group seems to be knowledgable about
    the topic of tracing; I wasn't able to talk to him though.
  - @japaric isn't available lately
  - ARMv7-M Architecture Reference Manual (DDI0403E) contains quite
    elaborate specification of tracing, ITM, DWT, TPIU and packeting
    format
  - https://github.com/japaric/itm-tools
    itm-tools utilizes following itm library
  - https://github.com/rust-embedded/itm
  - Notes:
    - itm-tools *probably* is not forgiving enough for data stream; if
      there's a lot of packet sources enabled like PC sampling +
      exception tracing + instrumentation * timestamping chance of
      malformed packets appearing increases (unless there's an
      implementation error in `itm-decode` or/and something itm/dwt/tpi
      is still somehow misconfigured)

** TODO Publish this document on some public repo, hack.md, or similar.
   Should be easy for others to contribute. (Github?)
   Otherwise, resultant notes are likely to be in the final report.


* Meeting at Grepit, [2021-01-28 Thu];
- Resolved openocd issue: openocd locks up on FIFO usage. A regular file works.

* Meeting at Grepit, [2021-02-04 Thu];
Nothing.

* Meeting at Grepit, [2021-02-11 Thu];
  - Probably a good idea to greenfield the any impl first.
  - probe-rs ITM API seems lackluster. Propose a new one if it comes up.

* Meeting at Grepit, [2021-02-18 Thu];
- Global/local timestamps to absolute time; see embedded-time.
- Resolve symbols; IRQ values to RTIC.
- Offline tool that displays recoded history. Proof of concepts. GUI
  tool? otherwise emacs interface with magit like detail menues.
  Simple GUI deps. Self-contained. txui: opengl based.
- Interleave ITM messages. That is: just write to stimulus ports and
  make sure they are decoded properly.
- read up on the protocol.
- we want ITM packets when resources are locked/unlock. Investigate.
  timestamp and reg value read/write (and/or lock-unlock).
* Meeting at Grepit, [2021-02-25 Thu]
- mention to probe-rs that I'm working on a better decoder, ask
  interested people to talk to me.
- add probe-rs feat to conf DBGMCU properly. Analyse all the other
  issues that talk about this.

* Meeting at Grepit, [2021-03-04 Thu];
- Hur smittar man upsteam med licenser för icke-commercial?
  - Inria
  - Sqlite3
* Meeting at Grepit, [2021-03-11 Thu];
- Start thinking what the daemon will actually do. It will present some
  convenient trace configuration API, anyhow.

* Project plan
#+BEGIN: clocktable :scope subtree :maxlevel 0 :step day :tstart "<-1d>" :tend "<now>" :compact t

Daily report: [2021-02-17 Wed]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *3:35* |
|--------------+--------|

Daily report: [2021-02-18 Thu]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *0:00* |
#+END:

** TODO Write thesis
   :LOGBOOK:
   CLOCK: [2021-02-17 Wed 11:58]--[2021-02-17 Wed 14:07] =>  2:09
   :END:
*** TODO Write about async vs. sync tracing to some extent
    When async, we can lose data because we sample at the wrong time, in
    difference to sync where we have a dedicated clock wire. See more:
    [[pdf:~/exjobb/docs/RM0368.pdf::833++0.00][RM0368.pdf: Page 833]].
** DONE Test ~itm-tools~ examples
   SCHEDULED: <2021-01-29 Fri>
   Just go through them from head to tail on the Nucleo.
   [[file:rtic-scope/src/main.rs][file:~/sync/uni/exjobb/rtic-scope/src/main.rs]]

   Notes:
   - The examples are for the STM32F1 family, but the Nucleo is a
     STM32F4. Port.
   - [[https://gitlab.henriktjader.com/pln/e7020e_2020/][Per's examples]] work with
     #+BEGIN_SRC openocd-internal
     monitor tpiu config internal /tmp/itm.fifo \
         16000000 # must match core freq
     #+END_SRC
     But they do not work with =cat /dev/ttyACM0= using
     #+BEGIN_SRC openocd-external
     monitor tpiu config external uart off 16000000 2000000
     #+END_SRC
     There simply is no output.

     *openocd-external does not work because I'm not using an external
     USART.* I'll use =config internal ./itm.fifo for now.

     =monitor mmw 0xE0001000 65536 4096= configures the DWT Control
     Register for exception tracing. This we must port to Rust.

     =monitor itm port 0 on= configures the availability of stimulus
     ports. We need not port this (for now).
** DONE Read up on probe-rs; start openocd -> probe-rs move         :@grepit:
   CLOSED: [2021-02-04 Thu 15:29] SCHEDULED: <2021-02-02 Tue>
   There are three main structures in ~probe-rs~. From each, the
   subsequent structure can be acquired.
   - Probe :: represents the physical probe in code form. Architecture agnostic.
   - Session :: an established connection of a *Probe* to a chip.
   - Core :: CPU manipulation.
** DONE Port openocd commands to Rust/probe-rs and replicate behavior
   CLOSED: [2021-02-14 Sun 00:23] DEADLINE: <2021-02-11 Thu>
   :LOGBOOK:
   CLOCK: [2021-02-12 Fri 18:15]--[2021-02-12 Fri 18:36] =>  0:21
   CLOCK: [2021-02-12 Fri 16:50]--[2021-02-12 Fri 17:46] =>  0:56
   CLOCK: [2021-02-10 Wed 15:01]--[2021-02-10 Wed 16:39] =>  1:38
   CLOCK: [2021-02-09 Tue 20:20]--[2021-02-09 Tue 21:32] =>  1:12
   CLOCK: [2021-02-09 Tue 18:40]--[2021-02-09 Tue 19:00] =>  0:20
   CLOCK: [2021-02-09 Tue 17:23]--[2021-02-09 Tue 18:22] =>  0:59
   CLOCK: [2021-02-09 Tue 15:03]--[2021-02-09 Tue 16:50] =>  1:47
   CLOCK: [2021-02-08 Mon 22:23]--[2021-02-08 Mon 22:43] =>  0:20
   CLOCK: [2021-02-08 Mon 21:39]--[2021-02-08 Mon 21:53] =>  0:14
   CLOCK: [2021-02-08 Mon 16:16]--[2021-02-08 Mon 19:18] =>  3:02
   :END:
   We want to ditch openocd in favour of ~probe-ps~. This may require
   some changes to the code base because ITM support is presently marked
   as "alpha". In essence, we need to translate whatever openocd does
   OOTB and the gdb commands (?) to a ~probe-rs~ environment.
   - Later these commands will be ported to probe.rs
   - Make sure to find manual references for all commands.

   *Build with symbols and -O0 and reverse engineer script*
   Functions of interest (when running as =openocd -d -f openocd.cfg=):
   - =target_write_u32= in =target.c:2482=
   - =adapter_write_memory= in =hla_target.c:783=
   Breakpoint these and inspect during runtime. Are there any other
   functions that write to target?
   *Must we concern ourselves with what probe-rs already writes?*

   *Below: what openocd does on startup*
   - Debug -302 :: checks CPUID and floating-point features, host-side setup
   - Debug 303-306 :: sets ~DHCSR = 0xa05f0001~; unlocks the register
     with ~0xa05f~ and enables debug-mode.
   - Debug 307-308 :: sets ~DEMCR = 0x01000000~; sets TRCENA: globally
     enables all DWT and ITM units.
   - *We go through Flash Patch and Break (FPB) unit*
   - Debug 309-310 :: reads ~FP_CTRL = 0x00000260~ (Flash Patch control
     register).
   - Debug 311-327 :: (probably) nulls the FPB comparator registers.
   - Debug 328-330 :: reads ~DWT_CTRL = 0x40000000~.
   - Debug 331-333 :: Reads some CoreSight management register (offset
     0xFBC, RO). Some ~DWT_DEVARCH = 0x0~.
   - Debug 334-335 :: Nulls ~DWT_FUNCTIONn~, $n = 0, ... 3$; disables them.
   - Debug 344-353 :: executes ~examine-end~:
     #+BEGIN_SRC tcl
       # Enable debug during low power modes (uses more power)
       # DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
       mmw 0xE0042004 0x00000007 0

       # Stop watchdog counters during halt
       # DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
       mmw 0xE0042008 0x00001800 0
     #+END_SRC
   - Debug 354-377 :: registers internal flash commands. Nothing
     seemingly written to device.
   - Debug 378-380 :: Initializes PLDs (?).
   - Debug 381-382 :: Starts GDB server.
   - Debug 383-- :: Shuts down.

*** DONE Port =monitor tpiu config internal itm.bin uart off 16000000=
    CLOSED: [2021-02-12 Fri 18:35]
    Alledgely, we should use
    #+BEGIN_SRC Rust
    Session::setup_svw({ Config { baudrate, clk }});
    #+END_SRC
    or something akin to it. [[https://docs.rs/probe-rs/0.10.1/probe_rs/struct.Session.html#method.setup_swv][See documentation]].

    #+begin_src
    Debug: 855 8837285 command.c:146 script_debug(): command - tpiu config internal itm.bin uart off 16000000
    Debug: 857 8837286 stlink_usb.c:1852 stlink_usb_trace_disable(): Tracing: disable
    Debug: 858 8837286 stlink_usb.c:1886 stlink_usb_trace_enable(): Tracing: recording at 2000000Hz
    #+end_src

    ~TPIU_CSPSR~, Current Parallel Port Size Register. See
    [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::810++10.99][DDI0403E_B_armv7m_arm.pdf: Page 810]]. Also [[pdf:~/exjobb/docs/RM0368.pdf::837++0.00][RM0368.pdf: Page 837]].
    - Sets bit 1 :: trace port size = 1.
    #+begin_src
    Debug: 859 8837286 target.c:2482 target_write_u32(): address: 0xe0040004, value: 0x00000001
    Debug: 860 8837286 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0040004 4 1
    #+end_src

    ~TPIU_ACPR~, Asynchronous Clock Prescalar Register. See
    [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::810++10.99][DDI0403E_B_armv7m_arm.pdf: Page 810]].
    - Sets :: sets the baud rate of the /Serial Wire Output/ (SWO) to
      Asynchronous_Reference_Clock/(SWOSCALAR +1).
    #+begin_src
    Debug: 861 8837286 target.c:2482 target_write_u32(): address: 0xe0040010, value: 0x00000007
    Debug: 862 8837286 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0040010 4 1
    #+end_src

    ~TPIU_SPPR~, Selected Pin Protocol Register. See
    [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::811++0.45][DDI0403E_B_armv7m_arm.pdf: Page 811]].
    Select the protocol used for the trace output.
    - Sets ~TXMODE=10~ :: Asynchronous SWO, using NRZ encoding.
    #+begin_src
    Debug: 863 8837287 target.c:2482 target_write_u32(): address: 0xe00400f0, value: 0x00000002
    Debug: 864 8837287 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe00400f0 4 1
    #+end_src

    ~TPIU_FFCR~, Formatter and Flush Control Register. See
    [[pdf:~/exjobb/docs/arm-cortex-m4-trm.pdf::95++8.49][arm-cortex-m4-trm.pdf: Page 95]].
    Clears ~EnFCont~, disables continuous formatting. That is, bypasses
    a formatter. *Only ITM, DWT packets is passed through. ETM packets
    are discarded*.
    #+begin_src
    Debug: 865 8837287 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe0040304 4 1
    Debug: 866 8837287 target.c:2394 target_read_u32(): address: 0xe0040304, value: 0x00000102
    Debug: 867 8837287 target.c:2482 target_write_u32(): address: 0xe0040304, value: 0x00000100
    Debug: 868 8837287 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0040304 4 1
    #+end_src

    ~DBGMCU_CR~, Debug MCU configuration register, mapped on the
    External PPB. See [[pdf:~/exjobb/docs/RM0368.pdf::828++2.21][RM0368.pdf: Page 828]].
    - Clears ~DBG_SLEEP~ :: all clocks are disabled in STOP mode.
    - Sets ~TRACE_IOEN~ :: TRACE pin assignment to default mode and size
      (~TRACE_MODE=00~: TRACE pin assignment for Asynchronous mode).
    #+begin_src
    Debug: 869 8837288 target.c:1626 target_call_event_callbacks(): target event 28 (trace-config) for core stm32f4x.cpu
    Debug: 870 8837288 target.c:4570 target_handle_event(): target(0): stm32f4x.cpu (hla_target) event: 28 (trace-config) action:
            # Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
            # change this value accordingly to configure trace pins
            # assignment
            mmw 0xE0042004 0x00000020 0

    Debug: 871 8837288 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe0042004 4 1
    Debug: 872 8837288 command.c:146 script_debug(): command - mww 0xE0042004 39
    Debug: 874 8837289 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0042004 4 1
    #+end_src

*** DONE Port =monitor mmw 0xE0001000 65536 4096=
    CLOSED: [2021-02-09 Tue 17:40]
    Writes the word (32 bits) =65536= to =4096= addresses starting at
    address =0xE0001000=.

    Documented as "EXCTRENA; clear PCSAMPLENA". Set these explicitly
    instead.
    See [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::799++0.05;;annot-799-1][DDI0403E_B_armv7m_arm.pdf: Page 799]].

    probe-rs code has been written, but when we read-back our changes
    the register holds the wrong data. Specifically, bit 16 is cleared
    while it should be set.
    - +Are we in the wrong state?+ Same behavior after =reset_and_halt=
      and just a =halt=/=wait_for_halt=.
    - There is a magical sequence openocd does that ensures ~DWT_CTRL~
      is clocked and ready for use. This we must reimplement.

    *DEMCR.TRCENA must be set first!* See [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::766++0.93][DDI0403E_B_armv7m_arm.pdf: Page 766]].

*** DONE Port =monitor itm port 0 on=
    CLOSED: [2021-02-10 Wed 15:56]
    Here we must [[file:~/code/openocd/src/target/armv7m_trace.c::armv7m->trace_config.itm_ter\[reg_idx\] |= (1 << port);][check the implementation]]. +Or perhaps we should just
    strace instead?+

    #+BEGIN_SRC C
    // In handle_itm_port_command
    uint8_t port = 0 % 32;
    armv7m->trace_config.itm_ter[reg_idx] |= (1 << port);

    // armv7m_trace_itm_config(target) is then run
       for (unsigned int i = 0; i < 8; i++) {
	       retval = target_write_u32(target, ITM_TER0 + i * 4,
					 trace_config->itm_ter[i]);
	       if (retval != ERROR_OK)
		       return retval;
       }
    // further down
    #define ITM_TER0 0xE0000E00
    int target_write_u32(struct target *target, target_addr_t address, uint32_t value);
    #+END_SRC

    We may not need the whole command, just whatever that allows us to
    get ITM packets to the host.

    [[file:~/code/openocd/contrib/itmdump.c::* - Software trace (ITM): so-called "printf-style" application messaging][Valueable notes on ITM from Openocd]]

    *Again, from =openocd -d4 -f openocd.cfg=*:
    From a =target extended-remote :3333=.
    - Info 380 :: gdb started
    - Debug 381-389 :: Delete all breakpoints, watchpoints and halt target.
    - Debug 390-438 :: Reads core register values (regs 0-22).
    - Debug 439-635 :: RWs a lot to =0xe000edf4= and =0xe000edf8=, the
      [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::651++6.19][Debug registers in the System Control Space in the Private
      Peripheral Bus (PPB).]]
      - 0xE000EDF4 :: [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::762++7.60][DCRSR/WO, Debug Core Register Selector Register]]
      - 0xE000EDF8 :: [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::764++2.79][DCRDR/RW, Debug Core Register Data Register]]
      *SR* is used to denote which core register or FPU-extension
      register we want to read/write, *DR* contains the content of the
      register we have selected. *DR* is a message-passing resource
      between an external debugger and the debug agent running on the
      processor. We only write to *SR* and read from *DR*.
    - Debug 640-643 :: check PC and read device ID from =0xe0042000=.
    - Debug 644-656 :: Read available flash memory and sectors, setup these
      internally.
    - Debug 657-679 :: Handle incoming GDB connection.
      [[file:rtic-scope/playground/debug.log::Debug: 657 235035 gdb_server.c:1016 gdb_new_connection(): New GDB Connection: 1, Target stm32f4x.cpu, state: halted][Continue from here]].
    - 680-830 :: repeat stuff

**** After a =monitor itm port 0 on=:
    [[file:~/code/openocd/src/target/armv7m_trace.c::retval = target_write_u32(target, ITM_LAR, ITM_LAR_KEY);][partial source]]

    Write key to ~ITM_LAR~ to unlock CoreSight registers. See
    [[pdf:~/exjobb/docs/coresight_v3_0_architecture_specification_IHI0029E.pdf::243++2.33][coresight_v3_0_architecture_specification_IHI0029E.pdf: Page 243]].
    *Deprecated starting from CoreSight v3.0*. Check ~LSR.SLI~ whether
    ~LAR~ is implemented or not.
    Target-documented in [[pdf:~/exjobb/docs/RM0368.pdf::825++1.15][RM0368.pdf: Page 825]].
    #+BEGIN_SRC fundamental
      Debug: 832 8647781 command.c:146 script_debug(): command - itm port 0 on
      Debug: 834 8647782 target.c:2482 target_write_u32(): address: 0xe0000fb0, value: 0xc5acce55
      Debug: 835 8647782 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000fb0 4 1
    #+END_SRC

    ~ITM_TCR~, Trace Control Register. See [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::776++4.61][DDI0403E_B_armv7m_arm.pdf: Page 776]].
    Sets
    - ITMENA :: master enable for ITM
    - TXENA :: forward DWT event packets to ITM
    - TraceBusID :: must be non-zero if multiple sources are to be used.
    #+BEGIN_SRC fundamental
      Debug: 836 8647782 target.c:2482 target_write_u32(): address: 0xe0000e80, value: 0x00010009
      Debug: 837 8647782 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e80 4 1
    #+END_SRC

    ~ITM_TERx~, Trace Enable Register(s). See [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::774++9.77][DDI0403E_B_armv7m_arm.pdf:
    Page 774]]. Enables stimulus port 0 and disables all other.
      #+begin_src fundamental
      Debug: 838 8647783 target.c:2482 target_write_u32(): address: 0xe0000e00, value: 0x00000001
      Debug: 839 8647783 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e00 4 1
      Debug: 840 8647783 target.c:2482 target_write_u32(): address: 0xe0000e04, value: 0x00000000
      Debug: 841 8647783 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e04 4 1
      Debug: 842 8647783 target.c:2482 target_write_u32(): address: 0xe0000e08, value: 0x00000000
      Debug: 843 8647783 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e08 4 1
      Debug: 844 8647784 target.c:2482 target_write_u32(): address: 0xe0000e0c, value: 0x00000000
      Debug: 845 8647784 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e0c 4 1
      Debug: 846 8647784 target.c:2482 target_write_u32(): address: 0xe0000e10, value: 0x00000000
      Debug: 847 8647784 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e10 4 1
      Debug: 848 8647785 target.c:2482 target_write_u32(): address: 0xe0000e14, value: 0x00000000
      Debug: 849 8647785 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e14 4 1
      Debug: 850 8647785 target.c:2482 target_write_u32(): address: 0xe0000e18, value: 0x00000000
      Debug: 851 8647785 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e18 4 1
      Debug: 852 8647785 target.c:2482 target_write_u32(): address: 0xe0000e1c, value: 0x00000000
      Debug: 853 8647785 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e1c 4 1
      #+end_src

*** DONE Load program
    CLOSED: [2021-02-12 Fri 20:18]
    :LOGBOOK:
    CLOCK: [2021-02-12 Fri 20:19]--[2021-02-12 Fri 20:21] =>  0:02
    CLOCK: [2021-02-12 Fri 19:05]--[2021-02-12 Fri 20:18] =>  1:13
    :END:
    Target flashing is done via =probe_rs_cli_util::download_file=.
    A function like it should be available in ~probe-rs~.

*** DONE Read ITM packets and record to file
    CLOSED: [2021-02-13 Sat 23:10]
    :LOGBOOK:
    CLOCK: [2021-02-13 Sat 22:23]--[2021-02-13 Sat 23:10] =>  0:47
    CLOCK: [2021-02-13 Sat 16:52]--[2021-02-13 Sat 17:16] =>  0:24
    CLOCK: [2021-02-13 Sat 03:23]--[2021-02-13 Sat 04:35] =>  1:12
    CLOCK: [2021-02-12 Fri 18:36]--[2021-02-12 Fri 19:05] =>  0:29
    :END:
    All commands are now ported to our ad-hoc scope. What we need to do
    now is to run the trace example using openocd, copy its debug log
    down below and see what it does to read out the ITM packets from
    STLink.

    After setting everything up and running =continue=:

    ~DEMCR~, Debug Exception and Monitor Control Register. See
    [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::765++0.01][DDI0403E_B_armv7m_arm.pdf: Page 765]].
    - Sets ~TRCENA~ :: global enable of all DWT and ITM features (again?).
    #+begin_src
    Debug: 1964 22935 gdb_server.c:3267 gdb_input_inner(): received packet: 'vCont?'
    Debug: 1965 22936 gdb_server.c:3267 gdb_input_inner(): received packet: 'vCont;c'
    Debug: 1966 22936 gdb_server.c:2740 gdb_handle_vcont_packet(): target stm32f4x.cpu continue
    Debug: 1967 22936 target.c:1626 target_call_event_callbacks(): target event 3 (resume-start) for core stm32f4x.cpu
    Debug: 1968 22936 hla_target.c:615 adapter_resume(): adapter_resume 1 0x00000000 0 0
    Debug: 1969 22936 target.c:1978 target_free_all_working_areas_restore(): freeing all working areas
    Debug: 1970 22936 target.c:1741 print_wa_layout():    0x20000000-0x20007fff (32768 bytes)
    Debug: 1971 22936 target.c:2482 target_write_u32(): address: 0xe000edfc, value: 0x01000000
    Debug: 1972 22936 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edfc 4 1
    #+end_src

    ~DCRDR~, Debug Core Register Data Register
    - Nulls register :: this is a message passing register. A previous
      write to ~DCRSR.REGSEL~ describes what was nulled here. See
      [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::763++0.00][DDI0403E_B_armv7m_arm.pdf: Page 763]].
    #+begin_src
    Debug: 1973 22936 armv7m.c:148 armv7m_restore_context():
    Debug: 1974 22936 target.c:2482 target_write_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 1975 22936 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf8 4 1
    #+end_src

    Various register readouts for GDB. Nothing relating to ITM packets.
    #+begin_src
    Debug: 1976 22937 target.c:1626 target_call_event_callbacks(): target event 2 (resumed) for core stm32f4x.cpu
    Debug: 1977 22937 target.c:1626 target_call_event_callbacks(): target event 4 (resume-end) for core stm32f4x.cpu
    Debug: 1978 22937 target.c:1626 target_call_event_callbacks(): target event 7 (gdb-start) for core stm32f4x.cpu
    Debug: 1979 23039 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 1980 23039 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 1981 23039 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1982 23040 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 0  value 0x0
    Debug: 1983 23040 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1984 23041 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 1  value 0x0
    Debug: 1985 23041 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1986 23041 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 2  value 0x8
    Debug: 1987 23041 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1988 23042 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 3  value 0x100
    Debug: 1989 23042 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1990 23042 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 4  value 0x0
    Debug: 1991 23042 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1992 23043 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 5  value 0x0
    Debug: 1993 23043 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1994 23044 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 6  value 0x0
    Debug: 1995 23044 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1996 23044 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 7  value 0x20007f40
    Debug: 1997 23044 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1998 23045 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 8  value 0x0
    Debug: 1999 23045 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2000 23046 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 9  value 0x0
    Debug: 2001 23046 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2002 23046 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 10  value 0x0
    Debug: 2003 23046 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2004 23047 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 11  value 0x0
    Debug: 2005 23047 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2006 23048 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 12  value 0x0
    Debug: 2007 23048 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2008 23048 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 13  value 0x20007f38
    Debug: 2009 23048 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2010 23049 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 14  value 0x80006d3
    Debug: 2011 23049 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2012 23050 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 15  value 0x8000ae6
    Debug: 2013 23050 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2014 23050 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 16  value 0x61000016
    Debug: 2015 23050 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2016 23051 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 17  value 0x20007f38
    Debug: 2017 23051 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2018 23051 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 18  value 0x0
    Debug: 2019 23051 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2020 23052 hla_target.c:130 adapter_load_core_reg_u32(): load from special reg 19 value 0x0
    Debug: 2021 23052 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2022 23052 hla_target.c:130 adapter_load_core_reg_u32(): load from special reg 20 value 0x0
    Debug: 2023 23052 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2024 23053 hla_target.c:130 adapter_load_core_reg_u32(): load from special reg 21 value 0x0
    Debug: 2025 23053 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2026 23053 hla_target.c:130 adapter_load_core_reg_u32(): load from special reg 22 value 0x0
    Debug: 2027 23053 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2028 23053 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000040
    Debug: 2029 23054 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2030 23054 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2031 23054 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2032 23054 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S0  value 0x0
    Debug: 2033 23054 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2034 23054 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000041
    Debug: 2035 23054 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2036 23055 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2037 23055 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2038 23055 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S1  value 0x0
    Debug: 2039 23055 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2040 23055 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000042
    Debug: 2041 23055 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2042 23056 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2043 23056 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2044 23056 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S2  value 0x0
    Debug: 2045 23056 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2046 23056 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000043
    Debug: 2047 23056 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2048 23057 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2049 23058 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2050 23058 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S3  value 0x0
    Debug: 2051 23058 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2052 23058 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000044
    Debug: 2053 23058 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2054 23058 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2055 23059 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2056 23059 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S4  value 0x0
    Debug: 2057 23059 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2058 23059 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000045
    Debug: 2059 23059 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2060 23059 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2061 23060 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2062 23060 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S5  value 0x0
    Debug: 2063 23060 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2064 23060 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000046
    Debug: 2065 23060 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2066 23060 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2067 23061 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2068 23061 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S6  value 0x0
    Debug: 2069 23061 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2070 23061 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000047
    Debug: 2071 23061 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2072 23061 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2073 23062 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2074 23062 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S7  value 0x0
    Debug: 2075 23062 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2076 23062 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000048
    Debug: 2077 23062 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2078 23063 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2079 23063 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2080 23063 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S8  value 0x0
    Debug: 2081 23063 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2082 23063 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000049
    Debug: 2083 23063 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2084 23064 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2085 23064 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2086 23064 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S9  value 0x0
    Debug: 2087 23064 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2088 23064 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004a
    Debug: 2089 23064 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2090 23065 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2091 23066 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2092 23066 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S10  value 0x0
    Debug: 2093 23066 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2094 23066 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004b
    Debug: 2095 23066 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2096 23066 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2097 23067 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2098 23067 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S11  value 0x0
    Debug: 2099 23067 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2100 23067 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004c
    Debug: 2101 23067 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2102 23067 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2103 23068 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2104 23068 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S12  value 0x0
    Debug: 2105 23068 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2106 23068 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004d
    Debug: 2107 23068 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2108 23069 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2109 23069 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2110 23069 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S13  value 0x0
    Debug: 2111 23069 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2112 23069 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004e
    Debug: 2113 23069 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2114 23070 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2115 23070 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2116 23070 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S14  value 0x0
    Debug: 2117 23070 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2118 23070 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004f
    Debug: 2119 23070 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2120 23071 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2121 23071 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2122 23072 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S15  value 0x0
    Debug: 2123 23072 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2124 23072 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000050
    Debug: 2125 23072 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2126 23072 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2127 23073 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2128 23073 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S16  value 0x0
    Debug: 2129 23073 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2130 23073 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000051
    Debug: 2131 23073 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2132 23073 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2133 23074 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2134 23074 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S17  value 0x0
    Debug: 2135 23074 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2136 23074 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000052
    Debug: 2137 23074 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2138 23075 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2139 23075 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2140 23075 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S18  value 0x0
    Debug: 2141 23075 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2142 23075 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000053
    Debug: 2143 23075 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2144 23076 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2145 23077 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2146 23077 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S19  value 0x0
    Debug: 2147 23077 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2148 23077 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000054
    Debug: 2149 23077 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2150 23077 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2151 23078 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2152 23078 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S20  value 0x0
    Debug: 2153 23078 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2154 23078 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000055
    Debug: 2155 23078 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2156 23078 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2157 23079 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2158 23079 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S21  value 0x0
    Debug: 2159 23079 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2160 23079 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000056
    Debug: 2161 23079 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2162 23080 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2163 23080 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2164 23080 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S22  value 0x0
    Debug: 2165 23080 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2166 23080 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000057
    Debug: 2167 23080 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2168 23081 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2169 23081 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2170 23081 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S23  value 0x0
    Debug: 2171 23081 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2172 23081 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000058
    Debug: 2173 23081 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2174 23082 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2175 23082 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2176 23083 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S24  value 0x0
    Debug: 2177 23083 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2178 23083 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000059
    Debug: 2179 23083 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2180 23107 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2181 23107 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2182 23107 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S25  value 0x0
    Debug: 2183 23107 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2184 23107 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005a
    Debug: 2185 23107 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2186 23108 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2187 23108 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2188 23108 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S26  value 0x0
    Debug: 2189 23108 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2190 23108 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005b
    Debug: 2191 23108 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2192 23109 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2193 23109 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2194 23109 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S27  value 0x0
    Debug: 2195 23109 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2196 23109 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005c
    Debug: 2197 23109 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2198 23110 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2199 23110 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2200 23110 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S28  value 0x0
    Debug: 2201 23110 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2202 23110 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005d
    Debug: 2203 23110 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2204 23111 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2205 23112 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2206 23112 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S29  value 0x0
    Debug: 2207 23112 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2208 23112 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005e
    Debug: 2209 23112 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2210 23112 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2211 23113 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2212 23113 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S30  value 0x0
    Debug: 2213 23113 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2214 23113 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005f
    Debug: 2215 23113 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2216 23114 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2217 23114 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2218 23114 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S31  value 0x0
    Debug: 2219 23114 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2220 23114 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000021
    Debug: 2221 23114 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2222 23115 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2223 23115 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2224 23116 hla_target.c:85 adapter_load_core_reg_u32(): load from FPSCR  value 0x0
    Debug: 2225 23175 hla_target.c:452 adapter_debug_entry(): entered debug state in core mode: Handler at PC 0x08000ae6, target->state: halted
    Debug: 2226 23175 target.c:1626 target_call_event_callbacks(): target event 0 (gdb-halt) for core stm32f4x.cpu
    Debug: 2227 23175 target.c:1626 target_call_event_callbacks(): target event 1 (halted) for core stm32f4x.cpu
    Debug: 2228 23175 target.c:1626 target_call_event_callbacks(): target event 8 (gdb-end) for core stm32f4x.cpu
    Debug: 2229 23175 hla_target.c:497 adapter_poll(): halted: PC: 0x08000ae6
    Debug: 2230 23175 gdb_server.c:3267 gdb_input_inner(): received packet: 'g'
    Debug: 2231 23176 gdb_server.c:3267 gdb_input_inner(): received packet: 'qXfer:threads:read::0,1000'
    Debug: 2232 23176 gdb_server.c:3267 gdb_input_inner(): received packet: 'm8000ae6,4'
    Debug: 2233 23176 gdb_server.c:1456 gdb_read_memory_packet(): addr: 0x0000000008000ae6, len: 0x00000004
    Debug: 2234 23176 target.c:2248 target_read_buffer(): reading buffer of 4 byte at 0x08000ae6
    Debug: 2235 23176 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0x08000ae6 2 2
    Debug: 2236 23178 gdb_server.c:3267 gdb_input_inner(): received packet: 'm8000ae6,2'
    Debug: 2237 23178 gdb_server.c:1456 gdb_read_memory_packet(): addr: 0x0000000008000ae6, len: 0x00000002
    Debug: 2238 23178 target.c:2248 target_read_buffer(): reading buffer of 2 byte at 0x08000ae6
    Debug: 2239 23178 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0x08000ae6 2 1
    #+end_src

    [[file:~/code/openocd/src/jtag/drivers/stlink_usb.c][It's not immidiately obvious how openocd records the ITM packets.]]

    [[file:~/code/probe-rs/probe-rs/src/session.rs::pub fn setup_swv(&mut self, config: &SwoConfig) -> Result<(), Error> {][~probe_rs~ contains some better leads]]: When calling =setup_swv= we
    do three things:
    1. Configure SWO on the probe
       1. +Starts receiving packets, somehow...+ Just tells the probe to
          recv. We may need an external UART adapter to recv ITM packets
          to host. Checkup with matix chat.
    2. Enable tracing on the target
       1. Sets ~DEMCR.TRCENA~
    3. [[file:~/code/probe-rs/probe-rs/src/architecture/arm/component/mod.rs::pub fn setup_swv(][Configure SWV on the target]]
       1. Sets ~DEMCR.TRCENA~
       2. Performs vendor-specific SWV setup
       3. Configures TPIU
       4. Configures ITM
       5. Configures DWT


    From OOTB of ~probe-rs~ with
    #+begin_src rust
      session.setup_swv(
            &SwoConfig::new(16_000_000)
                .set_baud(2_000_000)
                .set_continuous_formatting(false)
      )?;

      flash_program(&mut session)?;

      let mut f = File::create("/tmp/itm.bin")?;
      while let Ok(bytes) = session.read_swo() {
          if bytes.len() > 0 {
              f.write_all(&bytes)?;
          }
      }
    #+end_src
    We recv ITM packets, but seemingly no DWT packets. But if we combine
    the above with all other register writes, we get the exception
    traces.

    This is implemented in probe-rs:
    #+begin_src rust
      session.setup_swv(
          &SwoConfig::new(16_000_000)
              .set_baud(2_000_000)
              .set_continuous_formatting(false)
      )?;

      let component = session.get_arm_component()?;
      let mut core = session.core(0)?;
      Dwt::new(&mut core, &component).enable_exception_trace()?;
    #+end_src

** DONE Fork japaric/itm-tools and rewrite it for ~probe-rs~
   CLOSED: [2021-02-14 Sun 00:36]
   :LOGBOOK:
   CLOCK: [2021-02-13 Sat 23:14]--[2021-02-14 Sun 00:36] =>  1:22
   :END:
   We only concern ourselves with exception tracing for now, so only
   show how that is done.

   Done, see https://github.com/tmplt/itm-tools.

** DONE +Patch probe-rs to properly do exception tracing+
   :LOGBOOK:
   CLOCK: [2021-02-17 Wed 14:16]--[2021-02-17 Wed 15:02] =>  0:46
   :END:
   What does the below do, and how do we fix it for the stm32f401re?
   #+begin_src rust
     let comp = session.get_arm_component()?;
     let mut core = session.core(0)?;
     Dwt::new(&mut core, &comp).enable_exception_trace()?;
   #+end_src
   [[file:~/code/probe-rs/probe-rs/src/architecture/arm/component/dwt.rs::pub fn enable_exception_trace(&mut self) -> Result<(), Error> {][probe-rs source]].
   Only ~EXCTRCENA~ is set.
   ~DWT~ seems like a struct that only touches registers that relate to
   a single feature. =enable_exception_trace()= only sets ~EXCTRCENA~;
   =enable_data_trace()= enables and takes an address to monitor; etc.

   There is ~dwt.rs~ that touches DWT-related registers. Then there is
   ~itm.rs~ that touches ITM-related registers.

   Find an MWE that reproduces exception traces?

   itm-tools debugger reimplemented via probe-rs API. PC sample
   generation must be disabled however. itm-tools decoders do not handle
   exception traces and PC sample types.

** DONE Investigate the ITM decoder in probe-rs
   CLOSED: [2021-02-17 Wed 17:35]
   :LOGBOOK:
   CLOCK: [2021-02-19 Fri 14:30]--[2021-02-19 Fri 14:32] =>  0:02
   CLOCK: [2021-02-17 Wed 16:55]--[2021-02-17 Wed 17:35] =>  0:40
   :END:
   Implements decode for exception traces.

   We can trivially decode ITM packets via the probe-rs decoder.

   - Packets can be sent to any suitable trace sink. It mustn't be the
     TPIU.
   - TPIU forms packets into frames, as per CoreSight architecture spec.
   - TPIU transmits packets in LSB.

** DONE Investigate what https://github.com/orbcode/orbuculum is
   According to @therealprof, the author is receptive to discussion on
   the topic.

   See blog posts on http://shadetail.com/blog/.

   - The KCacheGrind feature is of notable interest.
   - Interactive help available at https://discord.gg/P7FYThy.
   - The author himself can probably be reached by tagging him on
     GitHub, or commit author email. <dave@marples.net>

** DONE Transmit trace over serial pin (SWO)
   CLOSED: [2021-04-07 Wed 13:41]
   :LOGBOOK:
   CLOCK: [2021-04-07 Wed 12:03]--[2021-04-07 Wed 13:38] =>  1:35
   CLOCK: [2021-04-07 Wed 09:58]--[2021-04-07 Wed 11:22] =>  1:24
   :END:
   STLink does not read all trace bytes from the target, so we must try
   with the serial pin instead. How do we enable it?

   The pin is denoted ~TRACESWO~ in [[pdf:~/exjobb/docs/RM0368.pdf::832++0.00][RM0368.pdf: Page 832]]. It is bound to
   PB3 on the Nucleo.

   - Some "serial wire mode; not in JTAG mode" for async mode (only a
     single wire is used)
   - Set ~TRACE_IOEN~ and ~TRACE_MODE = 0b00~ bits. Pin(s) not assigned
     by default.

   Signal is sent on PB3 with the above configured. Default behavior
   appears to be async pin.

   *What is the baud rate?* It is configured in ~TPIU_ACPR~,
   [[pdf:~/exjobb/docs/DDI0403E_d_armv7m_arm.pdf::752++0.23][DDI0403E_d_armv7m_arm.pdf: Page 752]]. SWO output clock =
   async_reference_clock/(swoscalar + 1).

   The async reference clock, HCLK, is 16MHz by default, so to set a
   115200 baud rate (yielding good bitsteam) prescalar must be set to
   =16_000_000 / 115_200 - 1=. Bitstream is then read via =stty -F
   /dev/ttyUSB3 115200; cat /dev/ttyUSB3 | tee itm.bin | xxd -b=.

   On the host, we need to set the following
   #+begin_src
   speed 9600 baud; line = 0;
   min = 100; time = 2;
   -icrnl -imaxbel
   -opost -onlcr
   -isig -icanon -echo
   #+end_src
   which can be done by calling =screen /dev/ttyUSB3 9600=

** TODO Setup some trace examples/demos?
   Right now we have a set of binaries (1) that we can trace, a separate
   "scope" that just flashes the binary and optionally enables tracing,
   and then a seperate utility that reads the SWO (stty/screen/cat).
   Should we combine them all into a program that does it all? Worthwhile?

   Further, the two functions that enable tracing on the target --- the one
   we run on the host, and the one we run on the target --- are
   isomorphic. Can we combine them somehow?
** DONE Resolve HW task symbol from IRQ number [3/3]
   CLOSED: [2021-04-20 Tue 16:17]
   :LOGBOOK:
   CLOCK: [2021-04-09 Fri 13:21]--[2021-04-09 Fri 16:04] =>  2:43

   CLOCK: [2021-04-09 Fri 10:35]--[2021-04-09 Fri 12:04] =>  1:29
   :END:
   On an exception trace we get an IRQ number, this should map to NVIC
   offset, which then maps to a HW task symbol.

   - irq2symb
   - tasks may not always map to external interrupts. So we must be able
     to map all exception numbers.
   - The vector table contains the entry point address of each exception
     handler. See [[pdf:~/exjobb/docs/DDI0403E_d_armv7m_arm.pdf::525++0.00][DDI0403E_d_armv7m_arm.pdf: Page 525]].
   - ~VTOR~ register tells us where the table is in memory.


   - How is the data that ends up in the vector table stored in the ELF?
   - Does the NVIC contain the info I think it does?
     - All NVIC interrupts have an assoc exception number as part of the
       ARMv7-M exception model. See [[pdf:~/exjobb/docs/DDI0403E_d_armv7m_arm.pdf::624++0.00][DDI0403E_d_armv7m_arm.pdf: Page 624]].
   - vector_table_addr = VTOR<31:7>:'0000000' exception number N found
     at offset N*0x4.
   - *How long is the table?* Max 496 external interrupts. Read
     ~SCS.ICTR.INTLINESNUM[3:0]~. See [[pdf:~/exjobb/docs/DDI0403E_d_armv7m_arm.pdf::618++0.00][DDI0403E_d_armv7m_arm.pdf: Page
     618]]. Number of interrupt lines is max(32 * (INTLINESNUM + 1), 496).
*** DONE Find handlers from ELF file instead of live target
    CLOSED: [2021-04-12 Mon 16:52]
    It lives somewhere in the ELF, that's for sure, but where? It's not
    related to flash algorithms, right?
    - Does ~memory.x~ or ~link.x~ tell us, perhaps?
      - Yes, the linker script ~link.x.in~ from cortex-m-rt tells us
        where symbols are stored. The vector table is stored at the
        start of flash, at ~.vector_table~.
      - =arm-none-eabi-objdump -t
        ../target/thumbv7em-none-eabihf/debug/tracing | sort= prints the
        file's symbols in order. ~.vector_table~ is then found at
        #+begin_src
08000000 l    d  .vector_table	00000000 .vector_table
08000004 g     O .vector_table	00000004 __RESET_VECTOR
08000008 g     O .vector_table	00000038 __EXCEPTIONS
08000008 g       .vector_table	00000000 __reset_vector
08000040 g     O .vector_table	00000154 __INTERRUPTS
08000040 g       .vector_table	00000000 __eexceptions
        #+end_src

    We have the symbols we need, now we just read the table starting
    from the address of the symbols? We should end up with the same data
    as when we probe the live target.


*** DONE Figure out the actual RTIC task name
    CLOSED: [2021-04-20 Tue 16:17]
    Here we probably need to dig around in DWARF debug. According to
    Mark, task name should be available under ~DW_TAG_subprogram~.

    gimli can help us here. See Mark's [[file:rauk/src/analysis/dwarf.rs::pub fn get_subprograms(dwarf: &Dwarf<EndianSlice<RunTimeEndian>>) -> Result<Vec<Subprogram>> {][rauk]] on how all RTIC task names
    are parsed out.

    In order we have
    - IRQ value
    - VTABLE offset
    - exception handler offset
    - ???
    - RTIC task name

    If we inspect the asm at EXTI0 (the task named ~blah~), we get the
    following:
    #+begin_src
$ arm-none-eabi-objdump -C --disassemble=EXTI0 rtic-scope/target/thumbv7em-none-eabihf/debug/tracing

rtic-scope/target/thumbv7em-none-eabihf/debug/tracing:     file format elf32-littlearm


Disassembly of section .text:

08000640 <EXTI0>:
 8000640:	b580      	push	{r7, lr}
 8000642:	466f      	mov	r7, sp
 8000644:	b082      	sub	sp, #8
 8000646:	2001      	movs	r0, #1
 8000648:	f807 0c01 	strb.w	r0, [r7, #-1]
 800064c:	f7ff fdea 	bl	8000224 <tracing::APP::EXTI0::{{closure}}>
 8000650:	2000      	movs	r0, #0
 8000652:	f000 f8ee 	bl	8000832 <cortex_m::register::basepri::write>
 8000656:	e7ff      	b.n	8000658 <EXTI0+0x18>
 8000658:	b002      	add	sp, #8
 800065a:	bd80      	pop	{r7, pc}
    #+end_src

    So, all RTIC tasks are called ~crate_name::APP~. However, further
    disassembly at ~<tracing::APP::EXTI0::{{closure}}>~ yields
    #+begin_src
08000224 <tracing::APP::EXTI0::{{closure}}>:
 8000224:	b580      	push	{r7, lr}
 8000226:	466f      	mov	r7, sp
 8000228:	b084      	sub	sp, #16
 800022a:	2001      	movs	r0, #1
 800022c:	f807 0c05 	strb.w	r0, [r7, #-5]
 8000230:	f000 f949 	bl	80004c6 <core::cell::Cell<T>::new>
 8000234:	f807 0c06 	strb.w	r0, [r7, #-6]
 8000238:	f817 0c06 	ldrb.w	r0, [r7, #-6]
 800023c:	f807 0c09 	strb.w	r0, [r7, #-9]
 8000240:	e7ff      	b.n	8000242 <tracing::APP::EXTI0::{{closure}}+0x1e>
 8000242:	f1a7 0009 	sub.w	r0, r7, #9
 8000246:	9003      	str	r0, [sp, #12]
 8000248:	e7ff      	b.n	800024a <tracing::APP::EXTI0::{{closure}}+0x26>
 800024a:	f000 f9cb 	bl	80005e4 <tracing::blah>
 800024e:	e7ff      	b.n	8000250 <tracing::APP::EXTI0::{{closure}}+0x2c>
 8000250:	b004      	add	sp, #16
 8000252:	bd80      	pop	{r7, pc}
    #+end_src
    where we find ~tracing::blah~.

*** DONE Find task names and interrupt numbers via rtic-syntax
    CLOSED: [2021-04-20 Tue 15:23]
    Instead of reversing the generated binary, in which we would have to
    scan for some ~crate_name::APP~ debug string, we can generate some
    "report" via RTIC codegen that contains a pairing of
    (PAC::Interrupt::nr(), task name), which is then trivially assoc'd
    with the exception number from SWO.

    We'll have to grok rtic-syntax and how its used in cortex-m-rtic to
    finally generate files (or does it just forward a final input to
    rustc?). Nevertheless, we want to read the source file, parse it
    with rtic-syntax, after which we should be able to extract all the
    data we need.

    Alternatively, if source files cannot be read into the proper
    format/type, perhaps we can generate a file beside binary in
    ~target/~?

    Essentially, we want to do something similar to [[file:cortex-m-rtic/macros/src/tests/single.rs::fn analyze() {][this test]].

    Start further grokking at [[file:cortex-m-rtic/macros/src/lib.rs::let (app, analysis) = match rtic_syntax::parse(args, input, settings) {][the app macro]].

    We can find the binding interrupt/exception to a task via
    [[file:rtic-syntax/src/ast.rs::pub binds: Ident,]]. ~binds: syn::Ident~
    has a ~to_string()~ impl.

    https://github.com/rtic-rs/rtic-syntax/issues/46

**** The possible approaches to exfiltrate data from an RTIC app
     What we want is to extract arbitrary information about an RTIC app
     from the app declaration in the source file. There are two possible
     ways of doing this: parsing the source file as a whole, and adding
     file I/O to the =#[app]= macro.

     - Parsing the whole source file :: available to us OOTB is
       =rtic_syntax::parse2= that can parse the RTIC application out of
       a =proc_macro2::TokenStream=. From this, we can trivially get the
       hardware tasks and their binding interrupts/exceptions. However,
       the function will only parse the arguments of the =#[app]=
       attribute macro. So if we want to parse the whole source file, we
       have to first make it a =TokenStream=:
#+begin_src rust
    let src = String::from_utf8_lossy(include_bytes!(
        "/home/tmplt/exjobb/rtic-scope/playground/src/bin/tracing.rs"
    ));

    let _syntax: TokenStream = syn::parse_str::<TokenStream>(&src).expect("Unable to parse file");
#+end_src
       then we have to remove all tokens such that only =mod app { ...
       }= remains. This would either warrant another parser to
       rtic-syntax that takes a full source file and returns the RTIC
       app, but the parser could also be exclusive to the resultant
       rtic-scope.

       With this approach, any edits in the source file may not
       necessarily propagate into the binary. Another approach is
       reading the full source file out of the ELF, then the only
       problem is whether or not the current binary is flashed or not.
       The actual source file can be used as a fall-back if source
       cannot be found in the ELF/DWARF.

     - Adding file I/O to the macro :: is another approach that would
       result in making the macro non-pure, and add functionality that
       only a very small subset of users would ever use. This approach
       would mean that the only way data is extracted is via a file
       (preferably under some ~target/rtic-scope~) or by communication
       via some daemon (which means that the daemon will have to be
       alive during binary genration). This approach seems like just
       being more moving parts.

     The =#[app]= attribute is (probably) a pure macro in the sense that
     is takes input code and return output code. I.e.

**** Figuring out the interrupt type
     The interrupt type is =PAC::Interrupt=. We can probably figure the
     PAC out from the arguments to the =#[app]= attribute and by looking
     around in rtic-syntax on how it is resolved, but it cannot be done
     dynamically because Rust itself lacks reflection.

     - Parse the source code of the PAC, specifically the =impl Nr=
       part. Messy.
     - Function that takes a PAC, builds a small library that we
       dynamically call that returns an assoc of interrupts/exception
       string representations and their integer values
     - build argument to rtic-scope where an =Interrupt= with =trait Nr=
       is given. rtic-scope would then be a wrapper for a larger rtic-adhoc-scope.
     - reverse the binary for string repr of exception handler (see [[file:rtic-scope/scope/src/bin/irq2symb.rs::// let function_name: String = if let Some(frame) = ctx.find_frames(handler as u64)?.next()?
       {][irq2symb]]).

     *We want to dynamically build what must be recompiled using cargo
     as a library into a small adhoc lib that does all type recovery*

     We can use cargo as a config with [[file:cargo/src/cargo/ops/cargo_compile.rs:://! The Cargo "compile" operation.][the compile operation]]. +We
     probably want to use ~cargo::core::Workspace::ephemeral~.+

** DONE syntax: figure out crate from rtic app
   CLOSED: [2021-04-20 Tue 17:05]
   Assumptions made: if the =#[app]= device arguments are formatted as
   =device = first::last=
   - The crate name is presumed to be =first=;
   - The required crate feature is =last=;
   - The device's interrupts are available via =first::last::Interrupt=.

** TODO Investigate watchpoint functionality for SW task tracing
   We may need watchpoints to trace sw tasks. The task queue should be
   monitored.

   Software tasks can nevertheless be extracted by parsing the RTIC app declaration.


** TODO Investigate why =enable_exception_trace= doesn't work
   :LOGBOOK:
   CLOCK: [2021-02-18 Thu 07:50]--[2021-02-18 Thu 08:18] =>  0:28
   :END:
   I may be misusing the API. It is confusing.

** TODO Translate ITM timestamps to absolute [80%]
   :LOGBOOK:
   CLOCK: [2021-02-19 Fri 09:02]--[2021-02-19 Fri 09:13] =>  0:11
   :END:
   That is, in this output
   #+begin_src fundamental
     ExceptionTrace { exception: ExternalInterrupt(22), action: Entered }
     TimeStamp { tc: 0, ts: 1627 }
     ExceptionTrace { exception: ExternalInterrupt(24), action: Entered }
     TimeStamp { tc: 0, ts: 183 }
     ExceptionTrace { exception: ExternalInterrupt(24), action: Exited }
     TimeStamp { tc: 0, ts: 1078 }
     ExceptionTrace { exception: ExternalInterrupt(23), action: Entered }
     TimeStamp { tc: 0, ts: 3 }
     ExceptionTrace { exception: ExternalInterrupt(23), action: Exited }
     TimeStamp { tc: 0, ts: 565 }
     ExceptionTrace { exception: ExternalInterrupt(22), action: Returned }
     TimeStamp { tc: 0, ts: 7 }
     Sync
     ExceptionTrace { exception: ExternalInterrupt(256), action: Returned }
     ItmData { id: 15, payload: [192, 255] }
     ItmData { id: 15, payload: [0, 0] }
     Sync
     ExceptionTrace { exception: ExternalInterrupt(256), action: Exited }
   #+end_src
   we want to filter out the relative (from when the target started)
   ~TimeStamp~ packets and generate absolute timestamps we can attach to
   all other packets.

*** DONE Read up on the ITM packet protocol
    CLOSED: [2021-02-19 Fri 14:32]
    :LOGBOOK:
    CLOCK: [2021-02-19 Fri 09:23]--[2021-02-19 Fri 10:49] =>  1:26
    :END:
    The packet protocol is described in [[pdf:~/exjobb/docs/DDI0403E_d_armv7m_arm.pdf::779++0.23][DDI0403E_d_armv7m_arm.pdf: Page
    779]].

    Notes:
    - If we want to provide an absolute timestamp (e.g. UNIX time, but
      also in nano-seconds) and save the bytesteam for later then we
      need to inject non-standard bytes into the local sink file.
    - If higher prio trace data uses all trace output bandwidth, ITM
      cannot output timestamp packets.

**** Local timestamps
     Delta timestamp since last local timestamp, to reduce bandwidth.
     Payload length depend on required timestamp value. When local
     timestamp packet is generated, the counter is reset to zero.

     Output synchronously (?) to corresponding ITM/DWT data.

     There are two formats to local timestamps:
     - format 1, two to five bytes (LTS1) :: ~TC[1:0]~ indicates the
       packet's relationship with corresponding ITM/DWT data.
     - format 2, single-byte :: only comprised of the packet header.
       Output when the required local timestamp vale is in the range
       1-6. Sync to ITM/DWT data.

**** Global timestamps
     Absolute timestamp values from a system timestamp clock. Can be
     used to provide correlation with other trace sources in the system.

     *Not necessarily supported by all implementations!*

     - Global timestamp it 48b or 64b; determined by implementation.
     - Two formats (for both sizes):
       - GTS1 :: transmits bits[25:0] of timestamp value, compressed by
         not transmitting higher-order bytes that match last global
         timestamp.
       - GTS2 :: transmits remaining timestamp bits in a 5- or 7-byte
         packet. This packet is always transferred in full.
     - A complete global timstamp value is thus transmitted using both a
       GTS1 and GTS2 packet, GTS1 packet first, then queues GTS2 when
       bandwidth is available. [[pdf:~/exjobb/docs/DDI0403E_d_armv7m_arm.pdf::785++8.24][May transmit multiple GTS1 packets before
       GTS2, with Wrap=1.]] GTS2 contains higher-order bit for the most
       recent GTS1.

**** Extension packets
     Provides additional information about the identified source. On
     ARMv7-M ITM and DWT packet protocol uses extension packets only to
     provide additional information for the decoding of Instumentation
     packets.

**** Source packets
     Two categories:
     - Softare source/application; instrumentation :: when software
       writes to an ITM stimulus port. Size of write transcation
       determines size of packet. If halfword is written, payload of
       halfword length is written. [[pdf:~/exjobb/docs/DDI0403E_d_armv7m_arm.pdf::788++8.96][If ITM impl. supports more than 32
       stimulus ports, extension packet is sent to indicate port.]]
     - Hardware source/diagnostics :: used for event counter wrapping,
       exception tracing, PC sampling, and data tracing. Extension
       packets possible, but unused for diagnostics on ARMv7-M.

*** DONE Investigate to what degree probe-rs decodes packets
    CLOSED: [2021-02-19 Fri 14:33]
    :LOGBOOK:
    CLOCK: [2021-02-19 Fri 11:06]--[2021-02-19 Fri 11:25] =>  0:19
    CLOCK: [2021-02-19 Fri 10:49]--[2021-02-19 Fri 10:51] =>  0:02
    :END:

    These is no symblic diff between global and local timestamps.

    The decoder is surface-level, and there is no assoc of timestamps to
    other packets. A new crate should be created.

*** DONE Finalize itm-decode library [6/6]
    CLOSED: [2021-03-06 Sat 00:28]

**** DONE Review error reporting enums
     CLOSED: [2021-03-01 Mon 16:38]
     Simplify if possible

**** DONE Thoroughly document
     CLOSED: [2021-03-02 Tue 15:01]
     Refer to ARM spec.

**** DONE Request =bitvec= feats upstream
     CLOSED: [2021-03-02 Tue 15:25]
     =pop_front=, check if feeding is performant

**** DONE Add tests
     CLOSED: [2021-03-03 Wed 13:27]
     Ideally we should have 100% branch coverage...

**** DONE replace adhoc example with a naive decoder
     CLOSED: [2021-03-03 Wed 14:10]
**** DONE Add option to decode stimulus strings
     CLOSED: [2021-03-06 Sat 00:28]

*** DONE Extend itm-decode to associate timestamp to data
    CLOSED: [2021-03-13 Sat 06:48]
    :LOGBOOK:
    CLOCK: [2021-02-23 Tue 11:40]--[2021-02-23 Tue 12:29] =>  0:49
    CLOCK: [2021-02-22 Mon 14:06]--[2021-02-22 Mon 15:45] =>  1:39
    CLOCK: [2021-02-22 Mon 11:29]--[2021-02-22 Mon 12:50] =>  1:21
    CLOCK: [2021-02-22 Mon 10:55]--[2021-02-22 Mon 11:24] =>  0:29
    CLOCK: [2021-02-20 Sat 09:30]--[2021-02-20 Sat 11:29] =>  1:59
    CLOCK: [2021-02-20 Sat 08:43]--[2021-02-20 Sat 09:08] =>  0:25
    CLOCK: [2021-02-20 Sat 08:29]--[2021-02-20 Sat 08:43] =>  0:14
    CLOCK: [2021-02-19 Fri 15:36]--[2021-02-19 Fri 16:40] =>  1:04
    :END:
    A global timestamp value is transmitted using a GTS1 and GTS2
    packet.

    Additionally, we need to handle Sync packets.

    Repo can be found at https://github.com/tmplt/itm-decode.

    - [2021-02-20 Sat] :: A new crate skeleton has replaced the previous
      code base. Next up it to copy =itm.bin= from ~itm-tools~, and make
      sure our bitmatch patterns work as expected.

*** TODO Verify that ITM output is expected [2/6]
    :LOGBOOK:
    CLOCK: [2021-02-23 Tue 15:16]--[2021-02-23 Tue 16:21] =>  1:05
    CLOCK: [2021-02-23 Tue 12:30]--[2021-02-23 Tue 14:07] =>  1:37
    CLOCK: [2021-02-23 Tue 11:40]--[2021-02-23 Tue 12:29] =>  0:49
    :END:

**** DONE Write another example to trace
     CLOSED: [2021-02-25 Thu 12:02]
     This example should periodically schedule a task so that LTS will
     eventually wrap.

**** STARTED Check if global timestamps are supported
     Gabriel says he only managed to generate GTS with ~ts = 0~. If we
     cannot generate proper GTS we cannot continue.

     Global timestamps can be generated by enabling them in
     ~ITM_TCR.GTSFREQ~, and in response to DWT requests(?).

     The GTS for the stm32f401re are 48-bit.

     - [2021-02-23 Tue 13:11] global timestamps are all zero.
     - [2021-02-23 Tue 14:05] the stm32f401re may not support global
       timestamps. A ticket has been submitted to ST that asks.

**** TODO Check we get an overflow packet when LTS wraps
     It seems like we get LTS periodically. Verify this.

**** TODO Check if we can interleave intrumentation packets
     Local timestamps aren't useless without a global timestamps, but we
     cannot get any global timestamps from them alone.

     *Weren't global timestamps optional?* "if an implementation
     supports global timestamping". See [[pdf:~/exjobb/docs/DDI0403E_d_armv7m_arm.pdf::785++0.00][DDI0403E_d_armv7m_arm.pdf: Page
     785]]. An ARMv7-M processor /can implement either or both/ of LTS,
     GTS.

**** TODO Generate a sync packet larger than 48b
     We need to see what happens when the packet's single set bit isn't
     in the last byte's MSB. Does the stm32f401re actually generate
     sync packets larger than this or does it just send

**** DONE Check if behavior changes when ensuring that master bus is powered
     See https://github.com/probe-rs/probe-rs/issues/350.

     Global timestamps are still zero

** TODO Add probe-rs feat that properly configures DBGMCU
   So that we do not brick the device.
** TODO Resolve IRQs to task symbol
   We need to read the ELF here. [[https://crates.io/crates/gimli][gimli]] should be able to help here.
   Niklas should be able to help.

** TODO Make sure we can interleave ITM payloads
   We may want to write arbitrary payloads to the ITM stimulus ports.
   Make sure we can actually do that while we exception trace.

   Will we hit "invalid" packets here, or was that just a thing with
   japaric's decoders?

** TODO Investigate how one would keep a tab on resource (locks)
   The DWT can take arbitrary addresses (although a limited set) and
   generate a timestamped (?) packet when such an address is
   read/written. *Note:* when resources are locked we don't inject any
   code (really?), the task's BASEPRI is changed, however. How can we
   keep tabs on when a resource is locked/unlocked?
   - Can we find the address where the lock is made, store this as a
     symbol in ELF and when watchpoint it?

** STARTED [#C] GUI tool that displays recoded trace
   Discuss the design more with Per before start. Depends on all other
   features. We don't want to pull any platform dependencies (i.e. we
   want to just =cargo install= it); investigate [[https://crates.io/crates/tuix][tuix]], which draws
   everything on an OpenGL canvas.

   An emacs-interface inspired by magit-history could be implemented
   also, but only I would use it.

   Look at the GUI design of https://percepio.com/tracealyzer/ for
   ideas.

   Yatekii is working on this. I will only be working with the daemon
   and backend components.

** The start: low hanging fruit
On task dispatch, send ITM package that contains task ID, scheduled
time, and global timestamp. Or, as a proof of concept: just send the ITM
package at the head of the task definition.

** Later: RTIC Scope
Host application that receives all ITM packages and ultimately present
them in a human-readable format to the end-user.

** In the end: task specific tracing
=#[task(trace = true)]= is the end-goal.

** In the very end: some useful GUI?

** RTIC Scope example applications
- Reimplment the segway system in an RTIC application. Verify
  that implementation /can/ match the underlying mathematical model. If
  this is done, send the report to Khalid. Also: keep Lukas updated
  about the presentation.
  - Sidestep MATLAB/Octave completely and do all computations
    symbolically in a Lisp?
  - Another great example would be a reimplementation of the line
    following robot done in mechatronical systems.
  - Ask Khalid about appropriate real-time goals.
  - Control theory + Lisp + RTIC kan bli riktigt bra blog-artiklar
    annars. Eller separata pubs? Extrem applicering av org-mode.

* Probe-rs thought
- The ITM/DWT packet protocol decoder is found under ~Struct
  probe_rs::architecture::arm::swo::Decoder~. ~swo~ is a bad name.
- [X] The provided decoder will be replaced.
- The receiver of a trace data stream is called a Trace Port Analyzer
  (TPA). See [[pdf:~/exjobb/docs/arm-cortex-m4-trm.pdf::92++0.00][arm-cortex-m4-trm.pdf: Page 92]]. We may want to adopt this
  term to be more easily found.
