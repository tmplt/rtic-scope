#+SEQ_TODO: TODO STARTED | DONE CANCELLED

* Master's theses in Rust and embedded systems
Next meet planned for [2021-01-15 Fri] before the next semester begins.

** Proposed theses
1. Safe approximation of path WCET
   - Topcs: KLEE; symbolic execution/verification; optimization levels/layers.
   - Application of research related to scheduling.
   - Probable communication with London team.
   - Analysis of how KLEE/LLVM behaves.
2. LLVM-IR as as approx WCET
   - Map LLVM-IR instuctions to architecture instuction count and
     execution time.
   - Topics: how programs are written; algorithms; trade-off between
     correctness and work-load; compilation technology/theory.
3. Program analasys using formal methods
   - Path explosion and how to detect and analyse them.
   - Topics: Mathematics, formal proofs
4. Tooling: RTIC -> test gen -> automated measurements -> analysis ->
   presentation.
   - Probably popular commercially.
5. Better debug for optimized code
   - DWARF in ELF
   - Probe.rs and/or GDB.
6. Map out tasks that take resources and send/recv messages in
   real-time.
   - Allegedly a lot applications.
   - Catch events from a host-site application and present them.
   - Related to thesis 4?
7. RTIC + FPGA + VHDL + RISCV
   - Experiments with interrupt HW implementation.
   - Porting RTIC to another architecture.
   - NVIC implementation.
   - Symbolic implementation of implementations.

* Meeting at Grepit, [2021-01-13 Wed]; RTIC Scope
- ITM-, ETM-baserad tracing
- TPUI periph
  - intern buffer
  - snackar seriellt över en ~swo~-port


** DONE Peripherals of interest
   SCHEDULED: <2021-01-18 Mon>
# Most descriptions are from the ARM Cortex-M4 Technical Reference Manual
- ITM :: Instumentation Trace Macrocell: application-driven trace source
  that supports =printf=-style debugging to trace operating system and
  application events, and generates diagnostic system information. The
  ITM generates trace information as packets from software traces, time
  stamping and global timestamping sources. [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::682++0.00][ITM is a non-invasive form
  of debugging.]]
- ETM :: real-time trace module providing instuction and data tracing of
  a processor. An ETM is an integral part of an ARM RealView debug solution.
- DWT :: Data Watchpoint and Trace: contains four comparators that can
  be configured as hardware watchpoints, ETM triggers, PC sampler event
  trigger, or a data address sampler event trigger.
- TPIU :: Trace Port Interface Unit: acts as a bridge between the
  on-chip trace data from the Embedded Trace Macrocell (ETM) and the
  Instumentation Trace Macrocell (ITM), with seperate IDs, to a data
  stream. The TPIU encapsulates IDs where required, and the data stream
  is then captured by a Trace Port Analyzer (TPA).
- RTT :: Real-Time Transfer: J-Link/SEGGER-defined protocol for tracing
  via memory buffer. Supported by ~probe.rs~. Allegedly implemented
  using a simple ring buffer.
- Watch points :: Similar to breakpoints; but instead of ~PC~ match,
  debug state is entered when a memory address of interest (and/or a
  variable) is accessed. Can be set on any memory address in any type of
  memory.

*** [[pdf:~/sync/uni/exjobb/dm00119316-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf::823++0.00][Instumentation Trace Macrocell]] (ITM)
The ITM emits trace information as packets which can be generated as:
- Software trace :: Software can write directly to the ITM stimulus
  registers to emit packets.
- Hardware trace :: The Data Watchpoint Trigger (DWT) generates these
  packets, and the ITM emits them.
- Time stamping :: Timestampings are emitted relative to packets. The
  ITM contains a 21-bit counter to generate the timestamp. The Cortex-M4
  with FPU clock or the bit clock rate of the /Serial Wire Viewer/ (SWV)
  outputs clocks the counter.

The packets are emitted by the ITM are output to the TPIU. The formatter
of the TPIU adds some extra packets and then output the complete packet
sequence to the debugger host.

**** Stimulus ports
- Write all ones to the Trace Privilege Register and read-back; the
  number of ones tell us how many stimulus ports the device has. Always
  a multiple of 8.
- [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::709++0.00][*Writes to stimulus ports must be properly aligned.*]] Non-aligned
  access is /unpredictable/.
- Data written, ~(port ID, write size, data)~, is combined into a packet
  written to FIFO.
- If FIFO is full, *packet disgarded*, and Overflow packet generated.
- Reading stimulus port register of enabled stim. port indicates buffer
  status. *Watchpoint this register to keep an eye on buffer status over
  ITM*. A proposed impl. detail is to check buffer status before
  stimulating. /How does this help?/
- *DWT uses a different output buffer*.

**** Timestamps
[[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::710++0.00][Provide information on the timing of event generation with respect to
their visibility at a trace output port.]]

***** Local timestamps
      Delta timestamp values: each local timestamp indicates the elapsed
      time since generating the previous local timestamp. Generated from
      the timestamp clock in the ITM peritheral. Clock is reset on each
      generation.

      Implementation definitions:
      - timestamp counter size;
      - [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::710++2.71][whether sync or async clock can be used and/or diveded]];

      When a timestamp counter overflows, timer is reset and Overflow
      packet is generated. Subsequently, a local timestamp packet is
      sent. This packet can be preemped, but will always have the
      appropriate value. Local timestamps are maximum 28b. Leading
      zeroes are truncated.

***** Global timestamps
      Absolute timestamp values based on a system global timestamp
      clock. 48b /or/ 68b large. Global timestamps are send in two
      packets.

**** Synchonization support
     Syncronization packets are regularly generated. These can be used
     as a system heartbeat, if enabled. Used to recover bit-to-byte
     aligngment information in a data stream.

*** [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::719++0.00][Data Watchpoint and Trace unit]] (DWT)
    Provides (implementation defined; *can be determined*):
    - Comparators, that support:
      - watchpoints (on memory address), causes the processor to enter Debug state of take a
        DebugMonitor exception;
      - data tracing;
      - signaling for use with an external resource, e.g. ETM;
      - PC value tracking;
      - Cycle count matching;
    - Additional PC sampling:
      - PC sample trace output as a result of a cycle count event;
      - external PC sampling using a PC sample register;
    - exception trace; and
    - performance profiling counters.


**** DWT comparators
     Includes up to 15 comparators that compares:
     - a data address;
     - an instuction address/mask (a range of addresses can be compared against);
     - a data value; and
     - the cycle count counter (comparator 0 only).

     A DWT Data trace packet contains:
     - address of the instuction that caused data access;
     - Bits[15:0] of data access address; and
     - matched data value.

     Exception trace packets can be generated when an exception handler
     is entered. Can also be generated when excpetion handler is
     returned from.

*** [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::749++0.00][Embedded Trace Macrocell]] (ETM)
    Specified in some other document, according to some ETM architecture
    v3.4.

*** [[pdf:~/sync/uni/exjobb/DDI0403E_d_armv7m_arm.pdf::750++0.00][Trace Port Interface Unit]] (TPIU)
    A simple bridge between internal debug peripherals (DWT, ITM) the
    outside world. An ARMv7-M compliant TPIU may provide an asynchronous
    /Serial Wire Output/ (SWO). SWO can be used to sidestep the STLink,
    and remove complexity from the export chain.

** DONE Read up on [[https://github.com/japaric/itm-tools][itm-tools]]
   CLOSED: [2021-01-19 Tue 22:14] SCHEDULED: <2021-01-18 Mon>

# Also read: RM368 for the stm32f401/f411, DDI0403E for the theory
# behind tracing and debugging, DDI0439B on some M4 definitions, RM0090
# (reference manual).

** Useful links
- [probe.rs]; we want to extend this and see how it works.
- [Druid] for GUI programming

** Notes
- modify the dispather to call ITM on dispatch, use ~probe.rs~ to catch
  ITM package, forward to host.
- how do we synchronize target and host? What needs to be synchronized?
  (Host and target are running in parallel here)
- intercept SWO line with dedicated hardware.
- HS probe :: open source programmer built from the ground up with the
  Rust in mind. Replicated by Grepit
- Serial TX on the Nucleo to bypass the ST-Link (which forces us to use
  openocd, which we do not want to use)
- Snacka med Johan gällande rymdapplikationer nu under 2021.
  - Specifikt med rymdföretag etablerade i Kiruna

* Meeting at Grepit, [2021-01-21 Thu];
** Notes
- "Knurling Defmt" for real-time tracing.
- =wfi= causes problems with ITM, RTT.
- Remove openocd from the chain as a start: TPIU must be configured just
  as in openocd. Lackluster API in probe.rs; fork it and experiment with
  values, etc.

** DONE fill in thesis template and submit
   CLOSED: [2021-01-25 Mon 15:34] SCHEDULED: <2021-01-25 Mon>

** TODO Merge Gabriel's notes below into this document
   Gabriel will work on some other stuff from now on.

*** Notes regarding ITM investigation/research
- Default clocks:
  - SAME5x: 48Mhz
  - F407: 16Mhz
  - F103: 8Mhz
- On SAME5x boards neither TPIU/ITM openocd commands nor probe-rs API is
  sufficient to enable ITM. *Additional steps*:
  - Enable ~GCLK_CM4_TRACE~ clock
  - Set PC27 into function M (~GCLK -> CORTEX_M/SWO~)
    - Question: Is it possible to setup SWO on PB30 pin and if so - how?
      (~SAM_D5xE5x_Family_Data_Sheet_DS60001507F.pdf~; p. 37)
- All platforms
  - Local timestamping (LTS; ~ITM.TCR.TSENA~ enabled) without asynchronous
    clock from TPIU (~ITM.TCR.SWOENA~ disabled) seems to work fine
    although there're also LTS packets without any event associated with
    it popping up regularly on SWO. These are supposedly overflow
    packets because the counter value they carry is suspiciously similar
    to MAX(21-bit unsigned) and LTS counter is 21 bit. This goes however
    against the specification that says that there should be Overflow
    packet + LTS packet, not just LTS packet (ARMv7-M arch ref
    manual; p. 711)
  - Local timestamping (LTS; ITM.TCR.TSENA enabled) with asynchronous
    clock from TPIU (ITM.TCR.SWOENA enabled) counts very slow and as
    such is pretty useless. I don't understand asynchronous clocking of
    ITM and what is it for so I didn't dig further
  - Global timestamping (GTS; ITM.TCR.GTSFREQ != 0x0) seems to be not
    clocked at all regardless of configuration (0x1,0x2,0x3). I couldn't
    find any additional information on the topic; maybe there's
    additional clock that needs to be setup on a per MCU basis?
  - PC sampling (DWT.CTRL.PCSAMPLENA enabled) does not work on F103;
    seems to work fine on F407. I didn't dig much further because I run
    out of time; sampling rate is configurable through other registers.
    If it's higher than ITM throughput - overflow guaranteed. I was able
    to use `pcsampl` tool to profile an application. Pretty nice.
  - Exception tracing (DWT.CTRL.EXCTRCENA enabled) does not work on
    F103; seems to work fine on F407. I was not able to parse SWO data
    with `excevt` because few malformed packets in datastream cause
    parser failure.
  - WFI does not seem to affect the behaviour of tracing module on F407
- Tools & URLs & Docs & Etc
  - @bcantrill from probe-rs Matrix group seems to be knowledgable about
    the topic of tracing; I wasn't able to talk to him though.
  - @japaric isn't available lately
  - ARMv7-M Architecture Reference Manual (DDI0403E) contains quite
    elaborate specification of tracing, ITM, DWT, TPIU and packeting
    format
  - https://github.com/japaric/itm-tools
    itm-tools utilizes following itm library
  - https://github.com/rust-embedded/itm
  - Notes:
    - itm-tools *probably* is not forgiving enough for data stream; if
      there's a lot of packet sources enabled like PC sampling +
      exception tracing + instrumentation * timestamping chance of
      malformed packets appearing increases (unless there's an
      implementation error in `itm-decode` or/and something itm/dwt/tpi
      is still somehow misconfigured)

** TODO Publish this document on some public repo, hack.md, or similar.
   Should be easy for others to contribute. (Github?)
   Otherwise, resultant notes are likely to be in the final report.


* Meeting at Grepit, [2021-01-28 Thu];
- Resolved openocd issue: openocd locks up on FIFO usage. A regular file works.

* Meeting at Grepit, [2021-02-04 Thu];
Nothing.

* Meeting at Grepit, [2021-02-11 Thu];
  - Probably a good idea to greenfield the any impl first.
  - probe-rs ITM API seems lackluster. Propose a new one if it comes up.

* Meeting at Grepit, [2021-02-18 Thu];
- Global/local timestamps to absolute time; see embedded-time.
- Resolve symbols; IRQ values to RTIC.
- Offline tool that displays recoded history. Proof of concepts. GUI
  tool? otherwise emacs interface with magit like detail menues.
  Simple GUI deps. Self-contained. txui: opengl based.
- Interleave ITM messages. That is: just write to stimulus ports and
  make sure they are decoded properly.
- read up on the protocol.
- we want ITM packets when resources are locked/unlock. Investigate.
  timestamp and reg value read/write (and/or lock-unlock).

* Project plan
#+BEGIN: clocktable :scope subtree :maxlevel 0 :step day :tstart "<-1d>" :tend "<now>" :compact t

Daily report: [2021-02-17 Wed]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *3:35* |
|--------------+--------|

Daily report: [2021-02-18 Thu]
| Headline     | Time   |
|--------------+--------|
| *Total time* | *0:00* |
#+END:

** TODO Write thesis
   :LOGBOOK:
   CLOCK: [2021-02-17 Wed 11:58]--[2021-02-17 Wed 14:07] =>  2:09
   :END:
** DONE Test ~itm-tools~ examples
   SCHEDULED: <2021-01-29 Fri>
   Just go through them from head to tail on the Nucleo.
   [[file:rtic-scope/src/main.rs][file:~/sync/uni/exjobb/rtic-scope/src/main.rs]]

   Notes:
   - The examples are for the STM32F1 family, but the Nucleo is a
     STM32F4. Port.
   - [[https://gitlab.henriktjader.com/pln/e7020e_2020/][Per's examples]] work with
     #+BEGIN_SRC openocd-internal
     monitor tpiu config internal /tmp/itm.fifo \
         16000000 # must match core freq
     #+END_SRC
     But they do not work with =cat /dev/ttyACM0= using
     #+BEGIN_SRC openocd-external
     monitor tpiu config external uart off 16000000 2000000
     #+END_SRC
     There simply is no output.

     *openocd-external does not work because I'm not using an external
     USART.* I'll use =config internal ./itm.fifo for now.

     =monitor mmw 0xE0001000 65536 4096= configures the DWT Control
     Register for exception tracing. This we must port to Rust.

     =monitor itm port 0 on= configures the availability of stimulus
     ports. We need not port this (for now).
** DONE Read up on probe-rs; start openocd -> probe-rs move         :@grepit:
   CLOSED: [2021-02-04 Thu 15:29] SCHEDULED: <2021-02-02 Tue>
   There are three main structures in ~probe-rs~. From each, the
   subsequent structure can be acquired.
   - Probe :: represents the physical probe in code form. Architecture agnostic.
   - Session :: an established connection of a *Probe* to a chip.
   - Core :: CPU manipulation.
** DONE Port openocd commands to Rust/probe-rs and replicate behavior
   CLOSED: [2021-02-14 Sun 00:23] DEADLINE: <2021-02-11 Thu>
   :LOGBOOK:
   CLOCK: [2021-02-12 Fri 18:15]--[2021-02-12 Fri 18:36] =>  0:21
   CLOCK: [2021-02-12 Fri 16:50]--[2021-02-12 Fri 17:46] =>  0:56
   CLOCK: [2021-02-10 Wed 15:01]--[2021-02-10 Wed 16:39] =>  1:38
   CLOCK: [2021-02-09 Tue 20:20]--[2021-02-09 Tue 21:32] =>  1:12
   CLOCK: [2021-02-09 Tue 18:40]--[2021-02-09 Tue 19:00] =>  0:20
   CLOCK: [2021-02-09 Tue 17:23]--[2021-02-09 Tue 18:22] =>  0:59
   CLOCK: [2021-02-09 Tue 15:03]--[2021-02-09 Tue 16:50] =>  1:47
   CLOCK: [2021-02-08 Mon 22:23]--[2021-02-08 Mon 22:43] =>  0:20
   CLOCK: [2021-02-08 Mon 21:39]--[2021-02-08 Mon 21:53] =>  0:14
   CLOCK: [2021-02-08 Mon 16:16]--[2021-02-08 Mon 19:18] =>  3:02
   :END:
   We want to ditch openocd in favour of ~probe-ps~. This may require
   some changes to the code base because ITM support is presently marked
   as "alpha". In essence, we need to translate whatever openocd does
   OOTB and the gdb commands (?) to a ~probe-rs~ environment.
   - Later these commands will be ported to probe.rs
   - Make sure to find manual references for all commands.

   *Build with symbols and -O0 and reverse engineer script*
   Functions of interest (when running as =openocd -d -f openocd.cfg=):
   - =target_write_u32= in =target.c:2482=
   - =adapter_write_memory= in =hla_target.c:783=
   Breakpoint these and inspect during runtime. Are there any other
   functions that write to target?
   *Must we concern ourselves with what probe-rs already writes?*

   *Below: what openocd does on startup*
   - Debug -302 :: checks CPUID and floating-point features, host-side setup
   - Debug 303-306 :: sets ~DHCSR = 0xa05f0001~; unlocks the register
     with ~0xa05f~ and enables debug-mode.
   - Debug 307-308 :: sets ~DEMCR = 0x01000000~; sets TRCENA: globally
     enables all DWT and ITM units.
   - *We go through Flash Patch and Break (FPB) unit*
   - Debug 309-310 :: reads ~FP_CTRL = 0x00000260~ (Flash Patch control
     register).
   - Debug 311-327 :: (probably) nulls the FPB comparator registers.
   - Debug 328-330 :: reads ~DWT_CTRL = 0x40000000~.
   - Debug 331-333 :: Reads some CoreSight management register (offset
     0xFBC, RO). Some ~DWT_DEVARCH = 0x0~.
   - Debug 334-335 :: Nulls ~DWT_FUNCTIONn~, $n = 0, ... 3$; disables them.
   - Debug 344-353 :: executes ~examine-end~:
     #+BEGIN_SRC tcl
       # Enable debug during low power modes (uses more power)
       # DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
       mmw 0xE0042004 0x00000007 0

       # Stop watchdog counters during halt
       # DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
       mmw 0xE0042008 0x00001800 0
     #+END_SRC
   - Debug 354-377 :: registers internal flash commands. Nothing
     seemingly written to device.
   - Debug 378-380 :: Initializes PLDs (?).
   - Debug 381-382 :: Starts GDB server.
   - Debug 383-- :: Shuts down.

*** DONE Port =monitor tpiu config internal itm.bin uart off 16000000=
    CLOSED: [2021-02-12 Fri 18:35]
    Alledgely, we should use
    #+BEGIN_SRC Rust
    Session::setup_svw({ Config { baudrate, clk }});
    #+END_SRC
    or something akin to it. [[https://docs.rs/probe-rs/0.10.1/probe_rs/struct.Session.html#method.setup_swv][See documentation]].

    #+begin_src
    Debug: 855 8837285 command.c:146 script_debug(): command - tpiu config internal itm.bin uart off 16000000
    Debug: 857 8837286 stlink_usb.c:1852 stlink_usb_trace_disable(): Tracing: disable
    Debug: 858 8837286 stlink_usb.c:1886 stlink_usb_trace_enable(): Tracing: recording at 2000000Hz
    #+end_src

    ~TPIU_CSPSR~, Current Parallel Port Size Register. See
    [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::810++10.99][DDI0403E_B_armv7m_arm.pdf: Page 810]]. Also [[pdf:~/exjobb/docs/RM0368.pdf::837++0.00][RM0368.pdf: Page 837]].
    - Sets bit 1 :: trace port size = 1.
    #+begin_src
    Debug: 859 8837286 target.c:2482 target_write_u32(): address: 0xe0040004, value: 0x00000001
    Debug: 860 8837286 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0040004 4 1
    #+end_src

    ~TPIU_ACPR~, Asynchronous Clock Prescalar Register. See
    [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::810++10.99][DDI0403E_B_armv7m_arm.pdf: Page 810]].
    - Sets :: sets the baud rate of the /Serial Wire Output/ (SWO) to
      Asynchronous_Reference_Clock/(SWOSCALAR +1).
    #+begin_src
    Debug: 861 8837286 target.c:2482 target_write_u32(): address: 0xe0040010, value: 0x00000007
    Debug: 862 8837286 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0040010 4 1
    #+end_src

    ~TPIU_SPPR~, Selected Pin Protocol Register. See
    [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::811++0.45][DDI0403E_B_armv7m_arm.pdf: Page 811]].
    Select the protocol used for the trace output.
    - Sets ~TXMODE=10~ :: Asynchronous SWO, using NRZ encoding.
    #+begin_src
    Debug: 863 8837287 target.c:2482 target_write_u32(): address: 0xe00400f0, value: 0x00000002
    Debug: 864 8837287 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe00400f0 4 1
    #+end_src

    ~TPIU_FFCR~, Formatter and Flush Control Register. See
    [[pdf:~/exjobb/docs/arm-cortex-m4-trm.pdf::95++8.49][arm-cortex-m4-trm.pdf: Page 95]].
    Clears ~EnFCont~, disables continuous formatting. That is, bypasses
    a formatter. *Only ITM, DWT packets is passed through. ETM packets
    are discarded*.
    #+begin_src
    Debug: 865 8837287 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe0040304 4 1
    Debug: 866 8837287 target.c:2394 target_read_u32(): address: 0xe0040304, value: 0x00000102
    Debug: 867 8837287 target.c:2482 target_write_u32(): address: 0xe0040304, value: 0x00000100
    Debug: 868 8837287 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0040304 4 1
    #+end_src

    ~DBGMCU_CR~, Debug MCU configuration register, mapped on the
    External PPB. See [[pdf:~/exjobb/docs/RM0368.pdf::828++2.21][RM0368.pdf: Page 828]].
    - Clears ~DBG_SLEEP~ :: all clocks are disabled in STOP mode.
    - Sets ~TRACE_IOEN~ :: TRACE pin assignment to default mode and size
      (~TRACE_MODE=00~: TRACE pin assignment for Asynchronous mode).
    #+begin_src
    Debug: 869 8837288 target.c:1626 target_call_event_callbacks(): target event 28 (trace-config) for core stm32f4x.cpu
    Debug: 870 8837288 target.c:4570 target_handle_event(): target(0): stm32f4x.cpu (hla_target) event: 28 (trace-config) action:
            # Set TRACE_IOEN; TRACE_MODE is set to async; when using sync
            # change this value accordingly to configure trace pins
            # assignment
            mmw 0xE0042004 0x00000020 0

    Debug: 871 8837288 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe0042004 4 1
    Debug: 872 8837288 command.c:146 script_debug(): command - mww 0xE0042004 39
    Debug: 874 8837289 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0042004 4 1
    #+end_src

*** DONE Port =monitor mmw 0xE0001000 65536 4096=
    CLOSED: [2021-02-09 Tue 17:40]
    Writes the word (32 bits) =65536= to =4096= addresses starting at
    address =0xE0001000=.

    Documented as "EXCTRENA; clear PCSAMPLENA". Set these explicitly
    instead.
    See [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::799++0.05;;annot-799-1][DDI0403E_B_armv7m_arm.pdf: Page 799]].

    probe-rs code has been written, but when we read-back our changes
    the register holds the wrong data. Specifically, bit 16 is cleared
    while it should be set.
    - +Are we in the wrong state?+ Same behavior after =reset_and_halt=
      and just a =halt=/=wait_for_halt=.
    - There is a magical sequence openocd does that ensures ~DWT_CTRL~
      is clocked and ready for use. This we must reimplement.

    *DEMCR.TRCENA must be set first!* See [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::766++0.93][DDI0403E_B_armv7m_arm.pdf: Page 766]].

*** DONE Port =monitor itm port 0 on=
    CLOSED: [2021-02-10 Wed 15:56]
    Here we must [[file:~/code/openocd/src/target/armv7m_trace.c::armv7m->trace_config.itm_ter\[reg_idx\] |= (1 << port);][check the implementation]]. +Or perhaps we should just
    strace instead?+

    #+BEGIN_SRC C
    // In handle_itm_port_command
    uint8_t port = 0 % 32;
    armv7m->trace_config.itm_ter[reg_idx] |= (1 << port);

    // armv7m_trace_itm_config(target) is then run
       for (unsigned int i = 0; i < 8; i++) {
	       retval = target_write_u32(target, ITM_TER0 + i * 4,
					 trace_config->itm_ter[i]);
	       if (retval != ERROR_OK)
		       return retval;
       }
    // further down
    #define ITM_TER0 0xE0000E00
    int target_write_u32(struct target *target, target_addr_t address, uint32_t value);
    #+END_SRC

    We may not need the whole command, just whatever that allows us to
    get ITM packets to the host.

    [[file:~/code/openocd/contrib/itmdump.c::* - Software trace (ITM): so-called "printf-style" application messaging][Valueable notes on ITM from Openocd]]

    *Again, from =openocd -d4 -f openocd.cfg=*:
    From a =target extended-remote :3333=.
    - Info 380 :: gdb started
    - Debug 381-389 :: Delete all breakpoints, watchpoints and halt target.
    - Debug 390-438 :: Reads core register values (regs 0-22).
    - Debug 439-635 :: RWs a lot to =0xe000edf4= and =0xe000edf8=, the
      [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::651++6.19][Debug registers in the System Control Space in the Private
      Peripheral Bus (PPB).]]
      - 0xE000EDF4 :: [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::762++7.60][DCRSR/WO, Debug Core Register Selector Register]]
      - 0xE000EDF8 :: [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::764++2.79][DCRDR/RW, Debug Core Register Data Register]]
      *SR* is used to denote which core register or FPU-extension
      register we want to read/write, *DR* contains the content of the
      register we have selected. *DR* is a message-passing resource
      between an external debugger and the debug agent running on the
      processor. We only write to *SR* and read from *DR*.
    - Debug 640-643 :: check PC and read device ID from =0xe0042000=.
    - Debug 644-656 :: Read available flash memory and sectors, setup these
      internally.
    - Debug 657-679 :: Handle incoming GDB connection.
      [[file:rtic-scope/playground/debug.log::Debug: 657 235035 gdb_server.c:1016 gdb_new_connection(): New GDB Connection: 1, Target stm32f4x.cpu, state: halted][Continue from here]].
    - 680-830 :: repeat stuff

**** After a =monitor itm port 0 on=:
    [[file:~/code/openocd/src/target/armv7m_trace.c::retval = target_write_u32(target, ITM_LAR, ITM_LAR_KEY);][partial source]]

    Write key to ~ITM_LAR~ to unlock CoreSight registers. See
    [[pdf:~/exjobb/docs/coresight_v3_0_architecture_specification_IHI0029E.pdf::243++2.33][coresight_v3_0_architecture_specification_IHI0029E.pdf: Page 243]].
    *Deprecated starting from CoreSight v3.0*. Check ~LSR.SLI~ whether
    ~LAR~ is implemented or not.
    Target-documented in [[pdf:~/exjobb/docs/RM0368.pdf::825++1.15][RM0368.pdf: Page 825]].
    #+BEGIN_SRC fundamental
      Debug: 832 8647781 command.c:146 script_debug(): command - itm port 0 on
      Debug: 834 8647782 target.c:2482 target_write_u32(): address: 0xe0000fb0, value: 0xc5acce55
      Debug: 835 8647782 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000fb0 4 1
    #+END_SRC

    ~ITM_TCR~, Trace Control Register. See [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::776++4.61][DDI0403E_B_armv7m_arm.pdf: Page 776]].
    Sets
    - ITMENA :: master enable for ITM
    - TXENA :: forward DWT event packets to ITM
    - TraceBusID :: must be non-zero if multiple sources are to be used.
    #+BEGIN_SRC fundamental
      Debug: 836 8647782 target.c:2482 target_write_u32(): address: 0xe0000e80, value: 0x00010009
      Debug: 837 8647782 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e80 4 1
    #+END_SRC

    ~ITM_TERx~, Trace Enable Register(s). See [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::774++9.77][DDI0403E_B_armv7m_arm.pdf:
    Page 774]]. Enables stimulus port 0 and disables all other.
      #+begin_src fundamental
      Debug: 838 8647783 target.c:2482 target_write_u32(): address: 0xe0000e00, value: 0x00000001
      Debug: 839 8647783 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e00 4 1
      Debug: 840 8647783 target.c:2482 target_write_u32(): address: 0xe0000e04, value: 0x00000000
      Debug: 841 8647783 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e04 4 1
      Debug: 842 8647783 target.c:2482 target_write_u32(): address: 0xe0000e08, value: 0x00000000
      Debug: 843 8647783 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e08 4 1
      Debug: 844 8647784 target.c:2482 target_write_u32(): address: 0xe0000e0c, value: 0x00000000
      Debug: 845 8647784 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e0c 4 1
      Debug: 846 8647784 target.c:2482 target_write_u32(): address: 0xe0000e10, value: 0x00000000
      Debug: 847 8647784 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e10 4 1
      Debug: 848 8647785 target.c:2482 target_write_u32(): address: 0xe0000e14, value: 0x00000000
      Debug: 849 8647785 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e14 4 1
      Debug: 850 8647785 target.c:2482 target_write_u32(): address: 0xe0000e18, value: 0x00000000
      Debug: 851 8647785 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e18 4 1
      Debug: 852 8647785 target.c:2482 target_write_u32(): address: 0xe0000e1c, value: 0x00000000
      Debug: 853 8647785 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe0000e1c 4 1
      #+end_src

*** DONE Load program
    CLOSED: [2021-02-12 Fri 20:18]
    :LOGBOOK:
    CLOCK: [2021-02-12 Fri 20:19]--[2021-02-12 Fri 20:21] =>  0:02
    CLOCK: [2021-02-12 Fri 19:05]--[2021-02-12 Fri 20:18] =>  1:13
    :END:
    Target flashing is done via =probe_rs_cli_util::download_file=.
    A function like it should be available in ~probe-rs~.

*** DONE Read ITM packets and record to file
    CLOSED: [2021-02-13 Sat 23:10]
    :LOGBOOK:
    CLOCK: [2021-02-13 Sat 22:23]--[2021-02-13 Sat 23:10] =>  0:47
    CLOCK: [2021-02-13 Sat 16:52]--[2021-02-13 Sat 17:16] =>  0:24
    CLOCK: [2021-02-13 Sat 03:23]--[2021-02-13 Sat 04:35] =>  1:12
    CLOCK: [2021-02-12 Fri 18:36]--[2021-02-12 Fri 19:05] =>  0:29
    :END:
    All commands are now ported to our ad-hoc scope. What we need to do
    now is to run the trace example using openocd, copy its debug log
    down below and see what it does to read out the ITM packets from
    STLink.

    After setting everything up and running =continue=:

    ~DEMCR~, Debug Exception and Monitor Control Register. See
    [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::765++0.01][DDI0403E_B_armv7m_arm.pdf: Page 765]].
    - Sets ~TRCENA~ :: global enable of all DWT and ITM features (again?).
    #+begin_src
    Debug: 1964 22935 gdb_server.c:3267 gdb_input_inner(): received packet: 'vCont?'
    Debug: 1965 22936 gdb_server.c:3267 gdb_input_inner(): received packet: 'vCont;c'
    Debug: 1966 22936 gdb_server.c:2740 gdb_handle_vcont_packet(): target stm32f4x.cpu continue
    Debug: 1967 22936 target.c:1626 target_call_event_callbacks(): target event 3 (resume-start) for core stm32f4x.cpu
    Debug: 1968 22936 hla_target.c:615 adapter_resume(): adapter_resume 1 0x00000000 0 0
    Debug: 1969 22936 target.c:1978 target_free_all_working_areas_restore(): freeing all working areas
    Debug: 1970 22936 target.c:1741 print_wa_layout():    0x20000000-0x20007fff (32768 bytes)
    Debug: 1971 22936 target.c:2482 target_write_u32(): address: 0xe000edfc, value: 0x01000000
    Debug: 1972 22936 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edfc 4 1
    #+end_src

    ~DCRDR~, Debug Core Register Data Register
    - Nulls register :: this is a message passing register. A previous
      write to ~DCRSR.REGSEL~ describes what was nulled here. See
      [[pdf:~/exjobb/docs/DDI0403E_B_armv7m_arm.pdf::763++0.00][DDI0403E_B_armv7m_arm.pdf: Page 763]].
    #+begin_src
    Debug: 1973 22936 armv7m.c:148 armv7m_restore_context():
    Debug: 1974 22936 target.c:2482 target_write_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 1975 22936 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf8 4 1
    #+end_src

    Various register readouts for GDB. Nothing relating to ITM packets.
    #+begin_src
    Debug: 1976 22937 target.c:1626 target_call_event_callbacks(): target event 2 (resumed) for core stm32f4x.cpu
    Debug: 1977 22937 target.c:1626 target_call_event_callbacks(): target event 4 (resume-end) for core stm32f4x.cpu
    Debug: 1978 22937 target.c:1626 target_call_event_callbacks(): target event 7 (gdb-start) for core stm32f4x.cpu
    Debug: 1979 23039 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 1980 23039 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 1981 23039 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1982 23040 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 0  value 0x0
    Debug: 1983 23040 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1984 23041 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 1  value 0x0
    Debug: 1985 23041 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1986 23041 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 2  value 0x8
    Debug: 1987 23041 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1988 23042 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 3  value 0x100
    Debug: 1989 23042 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1990 23042 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 4  value 0x0
    Debug: 1991 23042 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1992 23043 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 5  value 0x0
    Debug: 1993 23043 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1994 23044 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 6  value 0x0
    Debug: 1995 23044 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1996 23044 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 7  value 0x20007f40
    Debug: 1997 23044 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 1998 23045 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 8  value 0x0
    Debug: 1999 23045 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2000 23046 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 9  value 0x0
    Debug: 2001 23046 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2002 23046 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 10  value 0x0
    Debug: 2003 23046 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2004 23047 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 11  value 0x0
    Debug: 2005 23047 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2006 23048 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 12  value 0x0
    Debug: 2007 23048 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2008 23048 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 13  value 0x20007f38
    Debug: 2009 23048 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2010 23049 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 14  value 0x80006d3
    Debug: 2011 23049 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2012 23050 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 15  value 0x8000ae6
    Debug: 2013 23050 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2014 23050 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 16  value 0x61000016
    Debug: 2015 23050 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2016 23051 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 17  value 0x20007f38
    Debug: 2017 23051 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2018 23051 hla_target.c:74 adapter_load_core_reg_u32(): load from core reg 18  value 0x0
    Debug: 2019 23051 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2020 23052 hla_target.c:130 adapter_load_core_reg_u32(): load from special reg 19 value 0x0
    Debug: 2021 23052 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2022 23052 hla_target.c:130 adapter_load_core_reg_u32(): load from special reg 20 value 0x0
    Debug: 2023 23052 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2024 23053 hla_target.c:130 adapter_load_core_reg_u32(): load from special reg 21 value 0x0
    Debug: 2025 23053 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2026 23053 hla_target.c:130 adapter_load_core_reg_u32(): load from special reg 22 value 0x0
    Debug: 2027 23053 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2028 23053 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000040
    Debug: 2029 23054 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2030 23054 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2031 23054 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2032 23054 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S0  value 0x0
    Debug: 2033 23054 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2034 23054 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000041
    Debug: 2035 23054 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2036 23055 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2037 23055 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2038 23055 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S1  value 0x0
    Debug: 2039 23055 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2040 23055 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000042
    Debug: 2041 23055 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2042 23056 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2043 23056 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2044 23056 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S2  value 0x0
    Debug: 2045 23056 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2046 23056 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000043
    Debug: 2047 23056 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2048 23057 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2049 23058 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2050 23058 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S3  value 0x0
    Debug: 2051 23058 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2052 23058 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000044
    Debug: 2053 23058 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2054 23058 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2055 23059 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2056 23059 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S4  value 0x0
    Debug: 2057 23059 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2058 23059 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000045
    Debug: 2059 23059 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2060 23059 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2061 23060 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2062 23060 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S5  value 0x0
    Debug: 2063 23060 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2064 23060 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000046
    Debug: 2065 23060 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2066 23060 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2067 23061 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2068 23061 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S6  value 0x0
    Debug: 2069 23061 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2070 23061 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000047
    Debug: 2071 23061 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2072 23061 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2073 23062 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2074 23062 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S7  value 0x0
    Debug: 2075 23062 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2076 23062 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000048
    Debug: 2077 23062 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2078 23063 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2079 23063 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2080 23063 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S8  value 0x0
    Debug: 2081 23063 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2082 23063 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000049
    Debug: 2083 23063 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2084 23064 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2085 23064 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2086 23064 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S9  value 0x0
    Debug: 2087 23064 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2088 23064 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004a
    Debug: 2089 23064 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2090 23065 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2091 23066 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2092 23066 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S10  value 0x0
    Debug: 2093 23066 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2094 23066 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004b
    Debug: 2095 23066 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2096 23066 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2097 23067 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2098 23067 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S11  value 0x0
    Debug: 2099 23067 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2100 23067 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004c
    Debug: 2101 23067 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2102 23067 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2103 23068 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2104 23068 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S12  value 0x0
    Debug: 2105 23068 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2106 23068 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004d
    Debug: 2107 23068 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2108 23069 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2109 23069 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2110 23069 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S13  value 0x0
    Debug: 2111 23069 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2112 23069 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004e
    Debug: 2113 23069 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2114 23070 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2115 23070 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2116 23070 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S14  value 0x0
    Debug: 2117 23070 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2118 23070 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000004f
    Debug: 2119 23070 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2120 23071 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2121 23071 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2122 23072 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S15  value 0x0
    Debug: 2123 23072 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2124 23072 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000050
    Debug: 2125 23072 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2126 23072 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2127 23073 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2128 23073 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S16  value 0x0
    Debug: 2129 23073 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2130 23073 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000051
    Debug: 2131 23073 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2132 23073 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2133 23074 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2134 23074 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S17  value 0x0
    Debug: 2135 23074 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2136 23074 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000052
    Debug: 2137 23074 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2138 23075 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2139 23075 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2140 23075 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S18  value 0x0
    Debug: 2141 23075 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2142 23075 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000053
    Debug: 2143 23075 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2144 23076 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2145 23077 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2146 23077 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S19  value 0x0
    Debug: 2147 23077 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2148 23077 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000054
    Debug: 2149 23077 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2150 23077 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2151 23078 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2152 23078 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S20  value 0x0
    Debug: 2153 23078 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2154 23078 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000055
    Debug: 2155 23078 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2156 23078 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2157 23079 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2158 23079 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S21  value 0x0
    Debug: 2159 23079 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2160 23079 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000056
    Debug: 2161 23079 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2162 23080 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2163 23080 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2164 23080 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S22  value 0x0
    Debug: 2165 23080 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2166 23080 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000057
    Debug: 2167 23080 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2168 23081 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2169 23081 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2170 23081 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S23  value 0x0
    Debug: 2171 23081 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2172 23081 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000058
    Debug: 2173 23081 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2174 23082 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2175 23082 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2176 23083 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S24  value 0x0
    Debug: 2177 23083 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2178 23083 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000059
    Debug: 2179 23083 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2180 23107 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2181 23107 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2182 23107 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S25  value 0x0
    Debug: 2183 23107 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2184 23107 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005a
    Debug: 2185 23107 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2186 23108 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2187 23108 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2188 23108 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S26  value 0x0
    Debug: 2189 23108 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2190 23108 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005b
    Debug: 2191 23108 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2192 23109 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2193 23109 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2194 23109 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S27  value 0x0
    Debug: 2195 23109 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2196 23109 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005c
    Debug: 2197 23109 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2198 23110 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2199 23110 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2200 23110 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S28  value 0x0
    Debug: 2201 23110 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2202 23110 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005d
    Debug: 2203 23110 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2204 23111 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2205 23112 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2206 23112 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S29  value 0x0
    Debug: 2207 23112 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2208 23112 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005e
    Debug: 2209 23112 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2210 23112 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2211 23113 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2212 23113 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S30  value 0x0
    Debug: 2213 23113 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2214 23113 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x0000005f
    Debug: 2215 23113 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2216 23114 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2217 23114 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2218 23114 hla_target.c:96 adapter_load_core_reg_u32(): load from FPU reg S31  value 0x0
    Debug: 2219 23114 hla_target.c:59 adapter_load_core_reg_u32(): adapter_load_core_reg_u32
    Debug: 2220 23114 target.c:2482 target_write_u32(): address: 0xe000edf4, value: 0x00000021
    Debug: 2221 23114 hla_target.c:783 adapter_write_memory(): adapter_write_memory 0xe000edf4 4 1
    Debug: 2222 23115 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0xe000edf8 4 1
    Debug: 2223 23115 target.c:2394 target_read_u32(): address: 0xe000edf8, value: 0x00000000
    Debug: 2224 23116 hla_target.c:85 adapter_load_core_reg_u32(): load from FPSCR  value 0x0
    Debug: 2225 23175 hla_target.c:452 adapter_debug_entry(): entered debug state in core mode: Handler at PC 0x08000ae6, target->state: halted
    Debug: 2226 23175 target.c:1626 target_call_event_callbacks(): target event 0 (gdb-halt) for core stm32f4x.cpu
    Debug: 2227 23175 target.c:1626 target_call_event_callbacks(): target event 1 (halted) for core stm32f4x.cpu
    Debug: 2228 23175 target.c:1626 target_call_event_callbacks(): target event 8 (gdb-end) for core stm32f4x.cpu
    Debug: 2229 23175 hla_target.c:497 adapter_poll(): halted: PC: 0x08000ae6
    Debug: 2230 23175 gdb_server.c:3267 gdb_input_inner(): received packet: 'g'
    Debug: 2231 23176 gdb_server.c:3267 gdb_input_inner(): received packet: 'qXfer:threads:read::0,1000'
    Debug: 2232 23176 gdb_server.c:3267 gdb_input_inner(): received packet: 'm8000ae6,4'
    Debug: 2233 23176 gdb_server.c:1456 gdb_read_memory_packet(): addr: 0x0000000008000ae6, len: 0x00000004
    Debug: 2234 23176 target.c:2248 target_read_buffer(): reading buffer of 4 byte at 0x08000ae6
    Debug: 2235 23176 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0x08000ae6 2 2
    Debug: 2236 23178 gdb_server.c:3267 gdb_input_inner(): received packet: 'm8000ae6,2'
    Debug: 2237 23178 gdb_server.c:1456 gdb_read_memory_packet(): addr: 0x0000000008000ae6, len: 0x00000002
    Debug: 2238 23178 target.c:2248 target_read_buffer(): reading buffer of 2 byte at 0x08000ae6
    Debug: 2239 23178 hla_target.c:768 adapter_read_memory(): adapter_read_memory 0x08000ae6 2 1
    #+end_src

    [[file:~/code/openocd/src/jtag/drivers/stlink_usb.c][It's not immidiately obvious how openocd records the ITM packets.]]

    [[file:~/code/probe-rs/probe-rs/src/session.rs::pub fn setup_swv(&mut self, config: &SwoConfig) -> Result<(), Error> {][~probe_rs~ contains some better leads]]: When calling =setup_swv= we
    do three things:
    1. Configure SWO on the probe
       1. +Starts receiving packets, somehow...+ Just tells the probe to
          recv. We may need an external UART adapter to recv ITM packets
          to host. Checkup with matix chat.
    2. Enable tracing on the target
       1. Sets ~DEMCR.TRCENA~
    3. [[file:~/code/probe-rs/probe-rs/src/architecture/arm/component/mod.rs::pub fn setup_swv(][Configure SWV on the target]]
       1. Sets ~DEMCR.TRCENA~
       2. Performs vendor-specific SWV setup
       3. Configures TPIU
       4. Configures ITM
       5. Configures DWT


    From OOTB of ~probe-rs~ with
    #+begin_src rust
      session.setup_swv(
            &SwoConfig::new(16_000_000)
                .set_baud(2_000_000)
                .set_continuous_formatting(false)
      )?;

      flash_program(&mut session)?;

      let mut f = File::create("/tmp/itm.bin")?;
      while let Ok(bytes) = session.read_swo() {
          if bytes.len() > 0 {
              f.write_all(&bytes)?;
          }
      }
    #+end_src
    We recv ITM packets, but seemingly no DWT packets. But if we combine
    the above with all other register writes, we get the exception
    traces.

    This is implemented in probe-rs:
    #+begin_src rust
      session.setup_swv(
          &SwoConfig::new(16_000_000)
              .set_baud(2_000_000)
              .set_continuous_formatting(false)
      )?;

      let component = session.get_arm_component()?;
      let mut core = session.core(0)?;
      Dwt::new(&mut core, &component).enable_exception_trace()?;
    #+end_src

** DONE Fork japaric/itm-tools and rewrite it for ~probe-rs~
   CLOSED: [2021-02-14 Sun 00:36]
   :LOGBOOK:
   CLOCK: [2021-02-13 Sat 23:14]--[2021-02-14 Sun 00:36] =>  1:22
   :END:
   We only concern ourselves with exception tracing for now, so only
   show how that is done.

   Done, see https://github.com/tmplt/itm-tools.

** DONE +Patch probe-rs to properly do exception tracing+
   :LOGBOOK:
   CLOCK: [2021-02-17 Wed 14:16]--[2021-02-17 Wed 15:02] =>  0:46
   :END:
   What does the below do, and how do we fix it for the stm32f401re?
   #+begin_src rust
     let comp = session.get_arm_component()?;
     let mut core = session.core(0)?;
     Dwt::new(&mut core, &comp).enable_exception_trace()?;
   #+end_src
   [[file:~/code/probe-rs/probe-rs/src/architecture/arm/component/dwt.rs::pub fn enable_exception_trace(&mut self) -> Result<(), Error> {][probe-rs source]].
   Only ~EXCTRCENA~ is set.
   ~DWT~ seems like a struct that only touches registers that relate to
   a single feature. =enable_exception_trace()= only sets ~EXCTRCENA~;
   =enable_data_trace()= enables and takes an address to monitor; etc.

   There is ~dwt.rs~ that touches DWT-related registers. Then there is
   ~itm.rs~ that touches ITM-related registers.

   Find an MWE that reproduces exception traces?

   itm-tools debugger reimplemented via probe-rs API. PC sample
   generation must be disabled however. itm-tools decoders do not handle
   exception traces and PC sample types.

** DONE Investigate the ITM decoder in probe-rs
   CLOSED: [2021-02-17 Wed 17:35]
   :LOGBOOK:
   CLOCK: [2021-02-17 Wed 16:55]--[2021-02-17 Wed 17:35] =>  0:40
   :END:
   Implements decode for exception traces.

   We can trivially decode ITM packets via the probe-rs decoder.

** TODO Investigate why =enable_exception_trace= doesn't work
   :LOGBOOK:
   CLOCK: [2021-02-18 Thu 07:50]--[2021-02-18 Thu 08:18] =>  0:28
   :END:
   I may be misusing the API. It is confusing.

** TODO Translate ITM timestamps to absolute [0%]
   :LOGBOOK:
   CLOCK: [2021-02-19 Fri 09:02]--[2021-02-19 Fri 09:13] =>  0:11
   :END:
   That is, in this output
   #+begin_src fundamental
     ExceptionTrace { exception: ExternalInterrupt(22), action: Entered }
     TimeStamp { tc: 0, ts: 1627 }
     ExceptionTrace { exception: ExternalInterrupt(24), action: Entered }
     TimeStamp { tc: 0, ts: 183 }
     ExceptionTrace { exception: ExternalInterrupt(24), action: Exited }
     TimeStamp { tc: 0, ts: 1078 }
     ExceptionTrace { exception: ExternalInterrupt(23), action: Entered }
     TimeStamp { tc: 0, ts: 3 }
     ExceptionTrace { exception: ExternalInterrupt(23), action: Exited }
     TimeStamp { tc: 0, ts: 565 }
     ExceptionTrace { exception: ExternalInterrupt(22), action: Returned }
     TimeStamp { tc: 0, ts: 7 }
     Sync
     ExceptionTrace { exception: ExternalInterrupt(256), action: Returned }
     ItmData { id: 15, payload: [192, 255] }
     ItmData { id: 15, payload: [0, 0] }
     Sync
     ExceptionTrace { exception: ExternalInterrupt(256), action: Exited }
   #+end_src
   we want to filter out the relative (from when the target started)
   ~TimeStamp~ packets and generate absolute timestamps we can attach to
   all other packets.

*** TODO Read up on the ITM packet protocol
    :LOGBOOK:
    CLOCK: [2021-02-19 Fri 09:23]
    :END:

** TODO Resolve IRQs to task symbol
   We need to read the ELF here. [[https://crates.io/crates/gimli][gimli]] should be able to help here.

** TODO Make sure we can interleave ITM payloads
   We may want to write arbitrary payloads to the ITM stimulus ports.
   Make sure we can actually do that while we exception trace.

   Will we hit "invalid" packets here, or was that just a thing with
   japaric's decoders?

** TODO Investigate how one would keep a tab on resource (locks)
   The DWT can take arbitrary addresses (although a limited set) and
   generate a timestamped (?) packet when such an address is
   read/written. *Note:* when resources are locked we don't inject any
   code (really?), the task's BASEPRI is changed, however. How can we
   keep tabs on when a resource is locked/unlocked?
   - Can we find the address where the lock is made, store this as a
     symbol in ELF and when watchpoint it?

** TODO [#C] GUI tool that displays recoded trace
   Discuss the design more with Per before start. Depends on all other
   features. We don't want to pull any platform dependencies (i.e. we
   want to just =cargo install= it); investigate [[https://crates.io/crates/tuix][tuix]], which draws
   everything on an OpenGL canvas.

   An emacs-interface inspired by magit-history could be implemented
   also, but only I would use it.

** The start: low hanging fruit
On task dispatch, send ITM package that contains task ID, scheduled
time, and global timestamp. Or, as a proof of concept: just send the ITM
package at the head of the task definition.

** Later: RTIC Scope
Host application that receives all ITM packages and ultimately present
them in a human-readable format to the end-user.

** In the end: task speficic tracing
=#[task(trace = true)]= is the end-goal.

** In the very end: some useful GUI?

** RTIC Scope example applications
- Reimplment the segway system in an RTIC application. Verify
  that implementation /can/ match the underlying mathematical model. If
  this is done, send the report to Khalid. Also: keep Lukas updated
  about the presentation.
  - Sidestep MATLAB/Octave completely and do all computations
    symbolically in a Lisp?
  - Another great example would be a reimplementation of the line
    following robot done in mechatronical systems.
  - Ask Khalid about appropriate real-time goals.
  - Control theory + Lisp + RTIC kan bli riktigt bra blog-artiklar
    annars. Eller separata pubs? Extrem applicering av org-mode.
